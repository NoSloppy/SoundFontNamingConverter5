<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/png" href="favicon.png">
  <title>SoundFontNamingConverter (Browser-based)</title>
  <link rel="stylesheet" href="cleaned_styles.css">
</head>
<body>
  <h1>SoundFontNamingConverter MVP <span style="color:#fff;font-size:0.62em;">  Version FIVE </span></h1>

  <p style="text-align:center;margin-bottom:0.7em;">1. Choose a source and target format from the drop down menus below.</p>
  <form id="optionsForm" onsubmit="return false;">
    <select id="sourceBoard" name="sourceBoard" title="Source board">
      <option value="CFX">CFX</option>
      <option value="GOLDEN_HARVEST">Golden Harvest</option>
      <option value="PROFFIE">Proffieboard</option>
      <option value="VERSO">Verso</option>
      <option value="XENO3">Xeno 3</option>
    </select>
    <select id="targetBoard" name="targetBoard" title="Target board">
      <option value="CFX">CFX</option>
      <option value="GOLDEN_HARVEST">Golden Harvest</option>
      <option value="PROFFIE">Proffieboard</option>
      <option value="VERSO">Verso</option>
      <option value="XENO3">Xeno 3</option>
    </select>
  </form>
  <p style="text-align:center;margin-bottom:0.7em;">2. Select a folder of sound font files:</p>
  <div style="display:flex;justify-content:center;align-items:center;">
    <input type="file" id="folderInput" webkitdirectory multiple style="margin-bottom:0.5em;">
  </div>
    <div style="display:flex;justify-content:center;align-items:center;margin-bottom:0.7em;">
      <label style="color:#aaa; font-size:1.04em;">
        <input type="checkbox" id="mainHighPass"> Enable High-Pass Filter
      </label>
    </div>
  <div style="display:flex;justify-content:center;">
    <button id="renameBtn" disabled>Rename & Download Zip</button>
  </div>
  <!-- Audio‑Only Conversion Trigger -->
  <div class="audio-only-container" style="text-align:center; margin-bottom:1em;">
    <button type="button" id="audioOnlyButton" class="audio-only-button">Convert Audio Only</button>
  </div>
  <div id="log"></div>
  <div class="footer-container">
    <span class="footer-title">NoSloppy - 2025</span>
    <button id="versionChangelogButton" class="footer-button" title="View the version changelog" type="button">Version Changelog</button>
    <a href="https://www.buymeacoffee.com/BrianConner" title="Brian Conner supports the saber community. Support him back.">
      <img class="donate-button" src="donateButton.jpg" alt="Buy me a coffee"></a>
    <span class="footer-links">
      <span class="other-sites">Other sites:</span>
      <a href="https://nosloppy.github.io/ProffieOS-StyleEditor-1/style_editor_BC_V6.html" target="_blank" title="BC Style Editor"><img src="https://nosloppy.github.io/ProffieOS-StyleEditor-1/SE_Favicon.png" alt="BC Style Editor logo"></a>
      <a href="https://crucible.hubbe.net/" target="_blank" title="The Crucible"><img src="https://crucible.hubbe.net/uploads/default/optimized/1X/2237f551ca8f4f69ac478df5c64aee1c951c33f5_2_180x180.png" alt="Crucible logo"></a>
      <a href="https://pod.hubbe.net/" target="_blank" title="ProffieOS Documentation site"><img src="https://pod.hubbe.net/images/favicon.png" alt="Pod logo"></a>
      <a href="https://fredrik.hubbe.net/lightsaber/" target="_blank" title="Profezzorn's Proffieboard site"><img src="https://fredrik.hubbe.net/favicon.ico" alt="Lightsaber logo"></a>
      <a href="https://www.fett263.com/" target="_blank" title="Fett263's Style Library"><img src="https://www.fett263.com/favicon.ico" alt="Fett263 logo"></a>
      <a href="https://www.facebook.com/groups/opensourcesabers/" target="_blank" title="Open Source Group"><img src="https://www.facebook.com/favicon.ico" alt="Facebook logo"></a>
      <a href="https://crystalfocus.net/" target="_blank" title="crystalfocus.net"><img src="https://crystalfocus.net/images/logo.ico" alt="crystalfocus.net logo"></a>
      <a href="https://sabertec.net/" target="_blank" title="sabertec.net"><img src="https://sabertec.net/wp-content/uploads/2016/12/cropped-Logo-Sabertec-Bildmarke-V2-Hintergrund-32x32.png" alt="sabertec.net logo"></a>
      <a href="https://darkwolfsabers.com/" target="_blank" title="darkwolfsabers.com"><img src="https://img1.wsimg.com/isteam/ip/494b9647-5ed3-4359-92d3-188572d6d1f1/favicon/95b2b868-5641-4853-8c6d-057e8ebf1d55.jpeg/:/rs=w:16,h:16,m" alt="darkwolfsabers.com logo"></a>
    </span>
  </div>

  <!-- Load local UMD FFmpeg wrapper -->
  <script src="./ffmpeg/ffmpeg.js"></script>
  <script>
    // UMD exposes FFmpegWASM global
    if (!window.FFmpegWASM || typeof FFmpegWASM.FFmpeg !== 'function') {
      console.error('Local UMD FFmpegWASM failed to load; FFmpeg class is undefined.');
    } else {
      console.log('Local UMD FFmpegWASM loaded:', FFmpegWASM);
    }
    const { FFmpeg } = FFmpegWASM;
  </script>
  <div id="audioOnlyWindow" class="audio-only-window">
    <button type="button" id="audioCloseButton" class="close-button">&#10006;</button>
    <h2 class="centered-header">Convert to 44.1 kHz 16‑bit mono WAV</h2>
    <div style="margin:1em 0;">
      <input type="file" id="audioInput" webkitdirectory multiple>
    </div>
    <div style="margin-bottom:1em;">
      <label><input type="checkbox" id="audioHigh"> Enable High‑Pass Filter</label>
    </div>
    <div id="audioLog" style="margin-top:1em; width:100%; flex:1; overflow:auto; background:#23272b; padding:0.8em; color:#e2e2e2; font-family:'Fira Mono', monospace; font-size:0.95em; border-radius:0.4em;"></div>
    <button type="button" id="convertAudioButton" class="convert-audio-button">Convert Audio & Download Zip</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    console.log("HELLO FROM TOP OF SCRIPT");
    // Mapping CSV URLs for every board combo
    const CSV_URLS = {
      "CFX_TO_PROFFIE":             "CSV/CFX_TO_PROFFIE.csv",
      "GOLDEN_HARVEST_TO_PROFFIE":   "CSV/GOLDEN_HARVEST_TO_PROFFIE.csv",
      "PROFFIE_TO_CFX":             "CSV/PROFFIE_TO_CFX.csv",
      "PROFFIE_TO_GOLDEN_HARVEST":  "CSV/PROFFIE_TO_GOLDEN_HARVEST.csv",
      "PROFFIE_TO_VERSO":           "CSV/PROFFIE_TO_VERSO.csv",
      "PROFFIE_TO_XENO3":           "CSV/PROFFIE_TO_XENO3.csv",
      "VERSO_TO_PROFFIE":           "CSV/VERSO_TO_PROFFIE.csv",
      "XENO3_TO_PROFFIE":           "CSV/XENO3_TO_PROFFIE.csv"
    };

    // === DOM ===
    const logEl = document.getElementById('log');
    const folderInput = document.getElementById('folderInput');
    const sourceBoardEl = document.getElementById('sourceBoard');
    const targetBoardEl = document.getElementById('targetBoard');
    const renameBtn = document.getElementById('renameBtn');
    const renameHighPassCheckbox = document.getElementById('mainHighPass');

    // === State ===
    let files = [];
    let originalFiles = [];
    let mapping = {};
    let mappingReady = false;
    let conversionLogEntries = [];

    // Track recognition: Load known_tracks.txt from the same directory as index.html
    let knownTracksSet = new Set();

    async function loadKnownTracks() {
      try {
        const resp = await fetch('known_tracks.txt');
        if (resp.ok) {
          const txt = await resp.text();
          knownTracksSet = new Set(
            txt
              .split(/\r?\n/)
              .map(l =>
                l
                  .trim()
                  .toLowerCase()
              )
              .filter(l => l)
          );
          console.log("Loaded known tracks:", knownTracksSet);
        }
      } catch (err) {
        console.log("Could not load known_tracks.txt:", err);
        knownTracksSet = new Set();
      }
    }
    loadKnownTracks();

    // Logging
    function universalLog(el, msg, type = "default", className = "", afterFirst = false) {
      const colors = {
        info: "#99fff5",
        error: "#ffb0a5",
        success: "#9f6",
        default: "#e2e2e2"
      };

      const safeType = (type || "default").toLowerCase();
      const color = colors[safeType] || colors.default;

      const entry = document.createElement('div');
      entry.innerHTML = `<span style="color:${color}">${msg}</span>`;
      if (className) entry.classList.add(className);

      if (afterFirst && el.children.length > 1) {
        el.insertBefore(entry, el.children[1]);
      } else {
        el.appendChild(entry);
      }

      // Only add <br> if explicitly asked (e.g., msg === "")
      if (msg === "") {
        const br = document.createElement('br');
        if (className) br.classList.add(className);
        if (afterFirst && el.children.length > 2) {
          el.insertBefore(br, el.children[2]);
        } else {
          el.appendChild(br);
        }
      }
      if (el === logEl || el === audioLogEl) {
        if (afterFirst) {
          el.scrollTop = 0; // Scroll to top if we just inserted high-pass line
        } else {
          el.scrollTop = el.scrollHeight;
        }
      }
    }

    function logHighPass(el, afterFirst = false) {
      // Remove any existing High-Pass notes
      document.querySelectorAll('.high-pass-enabled').forEach(el => {
        const next = el.nextSibling;
        el.remove();
        if (next && next.nodeName === 'BR') next.remove();
      });
      universalLog(el, "High-Pass filtering enabled.", "info", "high-pass-enabled", afterFirst);
    }

    function clearLog() { logEl.innerHTML = ""; }

    function removeHighPassNote() {
      document.querySelectorAll('.high-pass-enabled').forEach(el => {
        const next = el.nextSibling;
        el.remove();
        if (next && next.nodeName === 'BR') next.remove();
      });
    }

    // Parse CSV (mapping) text into an object
    function parseCSV(csv) {
      const lines = csv.split(/\r?\n/);
      const map = {};
      for (const line of lines) {
        if (!line.trim()) continue;
        const [orig, renamed] = line.split(',').map(x => x.trim());
        if (orig && renamed) map[orig.toLowerCase()] = renamed;
      }
      return map;
    }

    function buildReverseMap(forwardMap) {
      const reverse = {};
      for (const [k, v] of Object.entries(forwardMap)) {
        if (!reverse[v]) reverse[v] = k;
      }
      return reverse;
    }

    // === Utility: single call to add to zip, conversionLogEntries, and log in one go ===
    function addZipEntry(zip, file, zipPath, label = 'Renamed') {
      zip.file(zipPath, file);
      // Determine source path: prefer original snapshot, fallback to webkitRelativePath
      const srcPath = file._original || file.webkitRelativePath;
      // Push to conversion log (normalize arrow)
      conversionLogEntries.push(`${label}: ${srcPath} -> ${zipPath}`);
      // Colorized on-screen log: white source, yellow arrow, green target
     universalLog(logEl,`Renamed: <span style="color:#fff">${srcPath}</span> <span style="color:#ff0">→</span> <span style="color:#9f6">${zipPath}</span>`);
    }

    // === Utility: unified track detection ===
    function isTrackFile(file) {
      const name = file.name.toLowerCase();
      const parts = file.webkitRelativePath.toLowerCase().split('/');
      return knownTracksSet.has(name)
          || parts.includes('tracks')
          || /(track|theme|song|music)/.test(name);
    }

    // Helper: Load direct or reverse mapping as object
    async function getMappingObj(csvKey, reverse = false) {
      const csv = await (await fetch(CSV_URLS[csvKey])).text();
      const obj = parseCSV(csv);
      return reverse ? buildReverseMap(obj) : obj;
    }

    // Combine reverse-of-first + direct second mapping in one call
    async function loadBidirectionalMapping(revKey, directKey) {
      const forward = await getMappingObj(revKey);
      const reverse = buildReverseMap(forward);
      const direct  = await getMappingObj(directKey);
      return { ...reverse, ...direct };
    }

    // === Log header/footer helpers ===
    function buildLogHeader(modeLabel, src, tgt, baseName) {
      let hdr =
        '------------------------------------------------\n' +
        'Renamed with SoundFontNamingConverter V5\n' +
        'Brian Conner a.k.a NoSloppy\n' +
        modeLabel + '\n' +
        new Date().toLocaleString() + '\n';
      hdr += '------------------------------------------------\n';
      return hdr;
    }

    // Unified banner helpers for logs and onscreen

    function buildFooterBanner() {
      return '<span style="color:#ffe066;font-weight:bold;">------------------ | **** MTFBWY **** | ------------------</span>';
    }

    // Helper to prompt user to select files for a renaming set
    function promptSelectFiles(src, tgt) {
      mappingReady = true;
     universalLog(logEl,`${src} → ${tgt} renaming set, please choose files above.`, "info");
      // Sync high-pass message
      document.querySelectorAll('.high-pass-enabled').forEach(el => {
        const next = el.nextSibling;
        el.remove();
        if (next && next.nodeName === 'BR') next.remove();
      });
      if (renameHighPassCheckbox.checked) {
        logHighPass(logEl, true);
        logEl.scrollTop = 0; // Scroll to top so message is visible
      }
      folderInput.disabled = false;
    }

    // Helper: finalize zip, build log, trigger download, and UI reset
    function finalizeAndDownload(src, tgt, zip, rootFolderName) {
      // Build header via unified helper
      const baseName = files[0]._original.split('/')[0];
      const header = buildLogHeader(
        'Font Renaming Log',
        src,
        tgt,
        baseName,
        renameHighPassCheckbox.checked
      );
      // Prepend the conversion header lines to the body
      const preBodyLines = [];
      preBodyLines.push(`Renaming: ${baseName} from ${src} to ${tgt}.`);
      if (renameHighPassCheckbox.checked) {
        preBodyLines.push('High-Pass filtering enabled.');
      }
      preBodyLines.push('');  // blank line after header lines
      // Build full body including CFX footnotes
      let bodyLines = [...preBodyLines, ...conversionLogEntries];
      if (tgt === 'CFX') {
        const pwroffCount = conversionLogEntries.filter(line => line.includes('pwroff2.wav')).length;
        if (pwroffCount >= 1) {
          const note1 = '-- CFX requires a "pwroff2" file for retractions when blade is moving.';
          const note2 = '-- So if only a single RETRACTION sound is received, it is made into both "poweroff" and "pwroff2" to fulfill the requirement.';
          bodyLines.push(note1, note2);
         universalLog(logEl,note1, 'info');
         universalLog(logEl,note2, 'info');
        }
        if (pwroffCount >= 2) {
          const note3 = '-- If a second RETRACTION sound comes through, then it is used for "pwroff2" instead, replacing the first instance.';
          const note4 = '-- Any additional RETRACTION sounds are then made as continued sequential "poweroff"s';
          bodyLines.push(note3, note4);
         universalLog(logEl,note3, 'info');
         universalLog(logEl,note4, 'info');
        }
      }
      // Build the file log by copying onscreen log entries:
      universalLog(logEl, "", "default");
      universalLog(logEl, `Renaming from ${src} → ${tgt} complete.`, "info");
      universalLog(logEl, buildFooterBanner(), "default");

      // Add to Audio-Only Conversion log:
      const rawLines = Array.from(logEl.querySelectorAll('div')).map(div => div.textContent.trim());
      const body = '\n' + rawLines.join('\n') + '\n';
      const logText = header + body;
      zip.file(`${rootFolderName}/_Conversion_Log.txt`, logText);

      // Zip Renamed files up
      zip.generateAsync({ type: 'blob' }).then(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const mainHpSuffix = renameHighPassCheckbox.checked ? '_HP' : '';
        a.download = `Renamed_${src}_to_${tgt}${mainHpSuffix}.zip`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => {
          universalLog(logEl, "<br><br>");
          renameBtn.disabled = false;
        }, 50);
      });
    }

    /**
     * Pre-processes files to handle non-wav, track, and extras files uniformly.
     * Moves handled files into the zip and returns only the core wav files for board-specific logic.
     */
    async function handleExtrasAndTracks(files, zip, log, conversionLogEntries, rootFolderName) {
      const remaining = [];
      const root = rootFolderName;
      for (const file of files) {
        if (file.name.startsWith('.')) continue;
        const nameLower = file.name.toLowerCase();
        // Use the preserved original path for logging when available
        const rel = file._original || file.webkitRelativePath;
        // 1) Non-wav files: copy any non-wav (e.g., .ini, .bmp) to root
        if (!nameLower.endsWith('.wav')) {
          const zipPath = `${root}/${file.name}`;
          zip.file(zipPath, file);
         universalLog(logEl,`<span style="color:#99fff5">- Moved non-wav file:</span> <span style="color:#fff">${rel}</span> <span style="color:#ff0">→</span> <span style="color:#9f6">${zipPath}</span>`);
          conversionLogEntries.push(`- Moved non-wav file ${rel} → ${zipPath}`);
          continue;
        }
        // 2) Track files: unified detection
        if (isTrackFile(file)) {
          const zipPath = `${root}/tracks/${file.name}`;
         universalLog(logEl,'(⌐■_■) This looks like a track file.', 'info');
          zip.file(zipPath, file);
         universalLog(logEl,`<span style="color:#99fff5">- Moved track file:</span> <span style="color:#fff">${rel}</span> <span style="color:#ff0">→</span> <span style="color:#9f6">${zipPath}</span>`);
          conversionLogEntries.push(`- Moved track file: ${rel} → ${zipPath}`);
          continue;
        }
        // 3) Extras/bonus folders
        const parts = rel.split('/');
        const idx = parts.map(p => p.toLowerCase()).findIndex(p => /(extra|xtra|bonus)/.test(p));
        if (idx !== -1) {
          const sub = parts.slice(idx + 1).join('/');
          const zipPath = `${root}/extras${sub ? '/' + sub : ''}`;
          zip.file(zipPath, file);
         universalLog(logEl,`<span style="color:#99fff5">- Moved extra or bonus file:</span> <span style="color:#fff">${rel}</span> <span style="color:#ff0">→</span> <span style="color:#9f6">${zipPath}</span>`);
          conversionLogEntries.push(`- Moved extra or bonus file: ${rel} → ${zipPath}`);
          continue;
        }
        // Otherwise, leave for board-specific processing
        remaining.push(file);
      }
      return remaining;
    }

    // Load CSV mapping as soon as both dropdowns are selected
    async function autoSelectAndLoadMapping() {
      // Reset UI
      mappingReady = false;
      renameBtn.textContent = 'Rename & Download Zip';
      renameBtn.disabled = true;
      folderInput.disabled = true;
      clearLog();

      const src = sourceBoardEl.value;
      const tgt = targetBoardEl.value;

      // Case 1: identical boards
      if (src === tgt) {
        if (src === "PROFFIE") {
         universalLog(logEl,"Proffieboard to Proffieboard organizes and renames a ProffieOS sound font for best FAT32 performance.", "info");
          mapping = {};
          mappingReady = true;
          folderInput.disabled = false;
          checkReady();
          // Add high-pass message if enabled
          if (renameHighPassCheckbox.checked) logHighPass(logEl, true);
        } else {
         universalLog(logEl,`Renaming from ${src} → ${tgt} is unnecessary.`, "info");
        }
        return;
      }

      // Case 2: chained conversion (neither PROFFIE)
      if (src !== "PROFFIE" && tgt !== "PROFFIE") {
        try {
          const srcToPro = await loadBidirectionalMapping(`PROFFIE_TO_${src}`, `${src}_TO_PROFFIE`);
          const proToTgt = await getMappingObj(`PROFFIE_TO_${tgt}`);
          mapping = key => {
            const lower = key.toLowerCase();
            const mid = srcToPro[lower] || lower;
            return proToTgt[mid.toLowerCase()] || mid;
          };
          promptSelectFiles(src, tgt);
          renameHighPassCheckbox.disabled = false;
          checkReady();
        } catch (e) {
         universalLog(logEl,`Failed to set up ${src}→${tgt} chained mapping: ${e}`, "error");
        }
        return;
      }

      // Case 3: direct conversion (one end PROFFIE)
      try {
        let mapObj;
        // mapping from other→PROFFIE
        if (tgt === "PROFFIE") {
          mapObj = await loadBidirectionalMapping(`PROFFIE_TO_${src}`, `${src}_TO_PROFFIE`);
        }
        // mapping from PROFFIE→other
        else if (src === "PROFFIE") {
          mapObj = await getMappingObj(`PROFFIE_TO_${tgt}`);
        }
        // fallback direct if CSV exists
        else {
          const key = `${src}_TO_${tgt}`;
          mapObj = CSV_URLS[key] ? await getMappingObj(key) : {};
        }
        mapping = mapObj;
        promptSelectFiles(src, tgt);
        renameHighPassCheckbox.disabled = false;
        checkReady();
      } catch (e) {
       universalLog(logEl,`Failed to load ${src}→${tgt} mapping: ${e}`, "error");
      }
    }

    // Check if ready for renaming
    function checkReady() {
      renameBtn.disabled = !(files.length && mappingReady);
    }

    // Folder/file picker handler
    folderInput.addEventListener('change', (e) => {
      files = Array.from(e.target.files);
      originalFiles = Array.from(e.target.files);
      clearLog();
      if (files.length) {
       universalLog(logEl,`Selected ${files.length} files from folder: <b>${files[0].webkitRelativePath.split('/')[0]}</b>`);
        if (mappingReady)universalLog(logEl,`${sourceBoardEl.value} → ${targetBoardEl.value} renaming ready.`, "info");
        if (renameHighPassCheckbox.checked) {
         universalLog(logEl,'High-Pass filtering enabled.', 'info');
        }
      }
      checkReady();
      renameBtn.textContent = 'Rename & Download Zip';
    });

    // Dropdown change handlers
    sourceBoardEl.addEventListener('change', autoSelectAndLoadMapping);
    targetBoardEl.addEventListener('change', autoSelectAndLoadMapping);
    autoSelectAndLoadMapping(); // On page load

    // Main High-Pass checkbox change logging (add/remove message as needed)
    renameHighPassCheckbox.addEventListener('change', () => {
      removeHighPassNote();
      if (renameHighPassCheckbox.checked) logHighPass(logEl, true);
    });

   async function fat32ProffieOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      // === Proffie altXXX folders support ===
      // collect any files under alt000, alt001, etc.
      const altFiles = files.filter(f => {
        const parts = f.webkitRelativePath.split('/');
        return /^alt\d{3}$/i.test(parts[1]);
      });
      if (altFiles.length) {
        // group by alt directory and by clean base name
        const altGroups = {};
        altFiles.forEach(f => {
          const parts = f.webkitRelativePath.split('/');
          const altDir = parts[1];
          const cleanName = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
          altGroups[altDir] = altGroups[altDir] || {};
          altGroups[altDir][cleanName] = altGroups[altDir][cleanName] || [];
          altGroups[altDir][cleanName].push(f);
        });
        const altDirs = Object.keys(altGroups).sort();
        // determine maximum count per base across all alt dirs
        const baseCounts = {};
        altDirs.forEach(dir => {
          Object.keys(altGroups[dir]).forEach(base => {
            baseCounts[base] = Math.max(baseCounts[base]||0, altGroups[dir][base].length);
          });
        });
        // fill missing entries by copying from any alt directory that has them
        altDirs.forEach(dir => {
          Object.entries(baseCounts).forEach(([base, count]) => {
            const arr = altGroups[dir][base] || [];
            for (let i = arr.length; i < count; i++) {
              // find first alt folder that has the file at this index
              let fileToCopy = null;
              for (const srcDir of altDirs) {
                const srcArr = altGroups[srcDir][base] || [];
                if (srcArr[i]) {
                  fileToCopy = srcArr[i];
                  break;
                }
              }
              if (fileToCopy) {
                arr.push(fileToCopy);
              }
            }
            altGroups[dir][base] = arr;
          });
        });
      // altBases: bases to process from alt groups
      const altBases = Object.keys(baseCounts);

      // incorporate stray root-level WAVs matching alt bases: distribute into each alt folder
      const strayRoot = files.filter(f => {
        const parts = f.webkitRelativePath.split('/');
        // skip files inside any altXXX folder
        if (!parts[1] || /^alt\d{3}$/i.test(parts[1])) return false;
        const clean = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        return altBases.includes(clean);
      });
      // add each stray file to every alt group
      strayRoot.forEach(f => {
        const clean = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        altDirs.forEach(dir => {
          altGroups[dir][clean].push(f);
        });
      });

      // remove altXXX files and stray root-level WAVs from main list
      files = files.filter(f => {
        const parts = f.webkitRelativePath.split('/');
        const isAltDir = /^alt\d{3}$/i.test(parts[1]);
        const clean = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        return !isAltDir && !altBases.includes(clean);
      });
      // --- handle numeric-only files: copy as-is before grouping ---
      const remainingAfterNumeric = [];
      for (const file of files) {
        if (/^\d+\.wav$/i.test(file.name)) {
          const parts = file.webkitRelativePath.split('/');
          const parent = parts[1] || '';
          const zipPath = parent
            ? `${rootFolderName}/${parent}/${file.name}`
            : `${rootFolderName}/${file.name}`;
          addZipEntry(zip, file, zipPath, 'Moved numeric file');
        } else {
          remainingAfterNumeric.push(file);
        }
      }
      files = remainingAfterNumeric;
        // now zip each alt group into its folder, numbering in sequence
        const applyMap = name => {
          const key = name.toLowerCase();
          const mapped = typeof mapping === 'function' ? mapping(key) : (mapping[key] || key);
          return mapped.replace(/\.wav$/, '');
        };
        altDirs.forEach(dir => {
          Object.entries(altGroups[dir]).forEach(([base, arr]) => {
            arr.forEach((f, idx) => {
              const mappedBase = applyMap(base);
              let outName;
              if (arr.length === 1) {
                // single per alt: no numeric suffix
                outName = `${mappedBase}.wav`;
              } else {
                // multiple: pad to two digits
                const suffix = String(idx+1).padStart(2, '0');
                outName = `${mappedBase}${suffix}.wav`;
              }
              const zipPath = `${rootFolderName}/${dir}/${outName}`;
              zip.file(zipPath, f);
              conversionLogEntries.push(`${f.webkitRelativePath} -> ${zipPath}`);
             universalLog(logEl,`Renamed: <span style="color:#fff">${f.webkitRelativePath}</span> <span style="color:#ff0">→</span> <span style="color:#9f6">${zipPath}</span>`);
            });
          });
        });
      }
      // If doing a Proffie→Proffie identity conversion, bypass all CSV mappings
      const isIdentityConversion = sourceBoardEl.value === 'PROFFIE' && targetBoardEl.value === 'PROFFIE';
      const applyMapping = name => {
        if (isIdentityConversion) return name;
        return typeof mapping === 'function' ? mapping(name) : (mapping[name] || name);
      };
      // Gather .wav files by base name, skip extras/bonus/track/music/etc folders for core handling
      const wavsByBase = {};
      const originals = {};
      // 1. Collect core wav files for FAT32 grouping
      for (const file of files) {
        if (file.name.startsWith('.') || !file.name.toLowerCase().endsWith('.wav')) continue;
        const nameLower = file.name.toLowerCase();
        const relParts = file.webkitRelativePath.split('/');
        let baseNameForGroup;
        if (/^\d+\.wav$/i.test(file.name) && relParts.length > 1) {
          baseNameForGroup = relParts[1].toLowerCase() + '.wav';
        } else {
          baseNameForGroup = nameLower.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        }
        const mapped = applyMapping(baseNameForGroup);
        const base = mapped.replace(/\.wav$/, '');
        wavsByBase[base] = wavsByBase[base] || [];
        wavsByBase[base].push(file);
        originals[file.name] = file.webkitRelativePath;
      }

      // 2. Handle all wavs in sorted order (for consistent numbering)
      for (const base of Object.keys(wavsByBase)) {
        let filesForBase = wavsByBase[base];
        filesForBase.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

        if (filesForBase.length === 1) {
          // Single file: strip Xeno (n) or trailing digits, map to Proffie, put in root
          let file = filesForBase[0];
          let cleanName = file.name.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav').toLowerCase();
          let mappedName = applyMapping(cleanName);
          let zipPath = `${rootFolderName}/${mappedName}`;
          addZipEntry(zip, file, zipPath);
        } else {
          // Multiples: put in subfolder, Proffie digits, mapped base name
          let file0 = filesForBase[0];
          let cleanName0 = file0.name.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav').toLowerCase();
          let mappedName0 = applyMapping(cleanName0);
          let mappedBase = mappedName0.replace(/\.wav$/, '');
          let subdir = `${rootFolderName}/${mappedBase}`;
          for (let i = 0; i < filesForBase.length; ++i) {
            let file = filesForBase[i];
            let num = i + 1;
            let useDoubleDigits = mappedBase.length <= 6;
            let useSingleDigit = mappedBase.length === 7 || mappedBase.length === 8;
            if (mappedBase === "tr") { useDoubleDigits = true; useSingleDigit = false; }
            let fileNum =
              mappedBase === "tr"
                ? String(num - 1).padStart(2, "0")
                : useDoubleDigits
                ? String(num).padStart(2, "0")
                : String(num);
            let newName = mappedBase + fileNum + ".wav";
            let zipPath = `${subdir}/${newName}`;
            addZipEntry(zip, file, zipPath);
          }
        }
      }
    }

    // --- CFX Organizer ---
    function CFXOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      const fileNameCounter = {};
      for (const file of files) {
        if (!file.name.toLowerCase().endsWith('.wav') || file.name.startsWith('.')) continue;
        // Numeric-only files: sequence by parent folder name
        if (/^\d+\.wav$/i.test(file.name)) {
          const parts = file.webkitRelativePath.split('/');
          const parent = parts.length > 1 ? parts[1] : '';
          const count = fileNameCounter[parent] || 1;
          const outName = `${parent}${count}.wav`;
          addZipEntry(zip, file, `${rootFolderName}/${outName}`);
          fileNameCounter[parent] = count + 1;
          continue;
        }
        // Map Proffie filenames to CFX names using the mapping object
        const origLower = file.name.toLowerCase();
        // Strip numeric suffixes for grouping (e.g. "boot01.wav" → "boot.wav")
        const keyForMapping = origLower.replace(/(\d+)\.wav$/i, '.wav');
        // Apply mapping on stripped key, fallback to stripped key
        const mappedName = (typeof mapping === "function")
          ? mapping(keyForMapping)
          : (mapping[keyForMapping] || keyForMapping);
        // Derive baseKey (without extension) for duplicate counting
        const baseKey = mappedName.replace(/\.wav$/i, '');
        let counter = fileNameCounter[baseKey] || 1;
        let outName;

        switch (baseKey) {
          case "poweroff":
            if (counter === 1) {
              // First poweroff and also create pwroff2
              addZipEntry(zip, file, `${rootFolderName}/poweroff.wav`);
              addZipEntry(zip, file, `${rootFolderName}/pwroff2.wav`, 'Also create pwroff2.wav');
            } else if (counter === 2) {
              // Updated pwroff2 replacement
              addZipEntry(zip, file, `${rootFolderName}/pwroff2.wav`, 'Updated pwroff2.wav');
            } else {
              const outName = `poweroff${counter - 1}.wav`;
              addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            }
            fileNameCounter[baseKey] = counter + 1;
            break;

          case "font":
            if (counter === 1) {
              outName = "font.wav";
            } else {
             universalLog(logEl,"- CFX only uses one font file, so any additional become boots.", 'info');
              conversionLogEntries.push("- CFX only uses one font file, so any additional become boots.");
              const bootCount = fileNameCounter["boot"] || 1;
              outName = `boot${bootCount === 1 ? "" : bootCount}.wav`;
              fileNameCounter["boot"] = bootCount + 1;
            }
            addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            fileNameCounter[baseKey] = counter + 1;
            break;

          case "boot":
          case "poweron":
          case "lockup":
          case "blaster":
          case "drag":
          case "force":
          case "color":
            outName = `${baseKey}${counter === 1 ? "" : counter}.wav`;
            addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            fileNameCounter[baseKey] = counter + 1;
            break;

          default:
            outName = `${baseKey}${counter}.wav`;
            addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            fileNameCounter[baseKey] = counter + 1;
            break;
        }
      }
    }

    // --- VERSO Organizer ---
    async function VERSOOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      // Pre-group all WAVs by base name (strip numeric suffixes)
      const filesByBase = {};
      for (const file of files) {
        if (!file.name.toLowerCase().endsWith('.wav') || file.name.startsWith('.')) continue;
        const key = file.name.toLowerCase().replace(/(\d+)\.wav$/i, '.wav');
        const mapped = (typeof mapping === "function")
          ? mapping(key)
          : (mapping[key] || key);
        const base = mapped.replace(/\.wav$/i, '');
        if (!filesByBase[base]) filesByBase[base] = [];
        filesByBase[base].push(file);
      }

      // Process each group
      for (const base of Object.keys(filesByBase).sort()) {
        const group = filesByBase[base];
        group.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
        // Special handling for font: first -> font.wav, rest -> fontALT1.wav, fontALT2.wav...
        if (base === 'font') {
          for (let i = 0; i < group.length; i++) {
            const file = group[i];
            const outName = i === 0
              ? 'font.wav'
              : `fontALT${i}.wav`;
            const zipPath = `${rootFolderName}/${outName}`;
            addZipEntry(zip, file, zipPath);
          }
        } else if (group.length === 1) {
          // Single file: base1.wav (always numbered)
          const file = group[0];
          const outName = `${base}1.wav`;
          const zipPath = `${rootFolderName}/${outName}`;
          addZipEntry(zip, file, zipPath);
        } else {
          // Multiple files: name1.wav, name2.wav, ...
          for (let i = 0; i < group.length; i++) {
            const file = group[i];
            const outName = `${base}${i + 1}.wav`;
            const zipPath = `${rootFolderName}/${outName}`;
            addZipEntry(zip, file, zipPath);
          }
        }
      }

      // Add mandatory Verso blast sound
      try {
        const resp = await fetch('Verso_Blast/blast1.wav');
        if (resp.ok) {
          const blob = await resp.blob();
          const blastZip = `${rootFolderName}/blast1.wav`;
          zip.file(blastZip, blob);
          // Verso-specific explanatory log
         universalLog(logEl,"-- Verso uses a 'blaster firing' sound before the 'deflection' sound, so it's been added for you.", "info");
          conversionLogEntries.push("-- Verso uses a 'blaster firing' sound before the 'deflection' sound, so it's been added for you.");
          // Add descriptive log for Verso blast requirement
          const versoMsg = "-- Added ";
         universalLog(logEl,`${versoMsg} → ${blastZip}`, "info");
          conversionLogEntries.push(`${versoMsg} -> ${blastZip}`);
        }
      } catch (err) {
       universalLog(logEl,"Failed to add Verso blast sound: " + err, "error");
      }
    }

    // ---GOLDEN HARVEST Organizer ---
    async function GHOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      const fileNameCounter = {};
      for (const file of files) {
        if (!file.name.toLowerCase().endsWith('.wav') || file.name.startsWith('.')) continue;
        const key = file.name.toLowerCase().replace(/(\d+)\.wav$/i, '.wav');
        const mapped = (typeof mapping === "function")
          ? mapping(key)
          : (mapping[key] || key);
        const base = mapped.replace(/\.wav$/i, '');
        let outName;
        if (base === 'font') {
          const cnt = (fileNameCounter[base] || 1);
          outName = cnt === 1 ? 'font.wav' : `fontALT${cnt-1}.wav`;
          fileNameCounter[base] = cnt + 1;
        } else {
          const cnt = (fileNameCounter[base] || 0) + 1;
          fileNameCounter[base] = cnt;
          outName = `${base}${cnt}.wav`;
        }
        const zipPath = `${rootFolderName}/${outName}`;
        addZipEntry(zip, file, zipPath);
      }
      // add settings.txt
      const resp = await fetch('GOLDEN_HARVEST_settings/settings.txt');
      if (resp.ok) {
        const blob = await resp.blob();
        const path = `${rootFolderName}/settings.txt`;
        zip.file(path, blob);
       universalLog(logEl,`-- Golden Harvest settings.txt added → ${path}`, "info");
        conversionLogEntries.push(`- Golden Harvest settings.txt added -> ${path}`);
      }
    }

    // --- XENO3 Organizer ---
    function XENO3Organizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      const fileNameCounter = {};
      for (const file of files) {
        // skip hidden and non-wav files
        if (file.name.startsWith('.') || !file.name.toLowerCase().endsWith('.wav')) continue;
        // strip any numeric suffix or parenthesized number for mapping
        const nameLower = file.name.toLowerCase();
        const cleanName = nameLower.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        // apply mapping to cleaned name
        let mappedWav;
        if (typeof mapping === 'function') {
          mappedWav = mapping(cleanName);
        } else {
          mappedWav = mapping[cleanName] || cleanName;
        }
        // strip extension for base
        const base = mappedWav.replace(/\.wav$/i, '');
        // increment counter for Xeno3 numbering
        const count = (fileNameCounter[base] || 0) + 1;
        fileNameCounter[base] = count;
        // build output name and path
        const outName = `${base} (${count}).wav`;
        const zipPath = `${rootFolderName}/${outName}`;
        addZipEntry(zip, file, zipPath);
      }
    }

      // === Audio normalization helper ===
      /**
       * Normalize a WAV or MP3 file to 44.1kHz, 16-bit mono with optional high-pass,
       * add result into zip at the same path, and log via callback.
       */
      async function normalizeAndZipAudio({ file, ffmpeg, zip, zipPath, audioHighPass, logFn, suppressConversionLog = false }) {
        const safeLog = logFn || ((msg, type = "info") => universalLog(audioLogEl, msg, type));

        // 1. Read and write original into MEMFS
        const arrayBuffer = await file.arrayBuffer();
        const inputName = file.name;
        await ffmpeg.writeFile(inputName, new Uint8Array(arrayBuffer));

        // 2. Determine temp output name
        //    For MP3 inputs, convert directly to .wav; for WAV inputs, use _tmp suffix
        const isMp3 = inputName.toLowerCase().endsWith('.mp3');
        const tempName = isMp3
          ? inputName.replace(/\.mp3$/i, '.wav')
          : inputName.replace(/\.[^\.]+$/, '_tmp.wav');

        // 3. Build FFmpeg args for conversion to 44.1kHz mono, strip all metadata
        const args = ['-i', inputName, '-vn', '-ar', '44100', '-ac', '1', '-map_metadata', '-1'];
        if (audioHighPass) {
          args.push('-af', 'highpass=f=100,highpass=f=100,highpass=f=100,volume=5dB');
        }
        args.push(tempName);

        // 4. Run conversion
        await ffmpeg.exec(args);

        // 5. Read converted output
        const outData = await ffmpeg.readFile(tempName);

        // 6. Add to zip at desired path
        zip.file(zipPath, outData);

        // 7. Log conversion (unless suppressed)
        if (!suppressConversionLog) {
          const source = file._original || file.webkitRelativePath;
          const msg =
            '<span style="color:#99fff5; font-weight:bold">Audio converted:</span> ' +
            `<span style="color:#fff">${source}</span> ` +
            '<span style="color:#ff0">→</span> ' +
            `<span style="color:#9f6">${zipPath}</span>`;
          logFn(msg, "default");
        }

        // 8. Clean up MEMFS
        await ffmpeg.deleteFile(inputName);
        await ffmpeg.deleteFile(tempName);
      }
      window.normalizeAndZipAudio = normalizeAndZipAudio;

      // --- Main renaming + zipping logic ---
      renameBtn.addEventListener('click', async () => {
        // Reset working file list from the original input on each run
        files = Array.from(originalFiles);
        // Preserve each file’s original path for consistent logging:
        files.forEach(f => { f._original = f.webkitRelativePath; });

        // Always create a new FFmpeg instance per run to reset memory
        const ffmpeg = new FFmpeg({ log: true, corePath: './ffmpeg/ffmpeg-core.js' });
        await ffmpeg.load();
        // Reset conversion log entries
        conversionLogEntries = [];
        clearLog();
        // Show header
       universalLog(logEl,`Renaming files: ${sourceBoardEl.value} → ${targetBoardEl.value}...\n`, "info");
        // Log high-pass status at the top if enabled
        if (renameHighPassCheckbox.checked) logHighPass(logEl, true);
        universalLog(logEl, "", "default");

        // Create new zip
        const zip = new JSZip();
        // Determine root folder name for zip, with optional HP suffix
        const mainHpSuffix = renameHighPassCheckbox.checked ? '_HP' : '';
        const baseName = originalFiles[0].webkitRelativePath.split('/')[0];
        const rootBase =
          (targetBoardEl.value.toUpperCase() === 'GOLDEN_HARVEST'
            ? `sound1 - ${baseName}_${targetBoardEl.value}`
            : `${baseName}_${targetBoardEl.value}`);
        const rootFolderName = `${rootBase}${mainHpSuffix}`;

        // Pre-convert audio files (MP3/MP4 and non-44.1kHz/16-bit WAV) to proper WAV before renaming
        const processedFiles = [];
        for (const file of files) {
          const lower = file.name.toLowerCase();
          let needsConvert = false;
          if (lower.endsWith('.mp3') || lower.endsWith('.mp4')) {
            needsConvert = true;
          } else if (lower.endsWith('.wav')) {
            const arr = await file.arrayBuffer();
            const view = new DataView(arr);
            const sampleRate = view.getUint32(24, true);
            const bits = view.getUint16(34, true);
            // Convert if format is wrong or high-pass filtering is requested
            if (sampleRate !== 44100 || bits !== 16 || renameHighPassCheckbox.checked) needsConvert = true;
          }
          if (needsConvert) {
            const originalPath = file.webkitRelativePath;
            const tempName = file.name.replace(/\.[^\.]+$/, '_tmp.wav').replace(/\.mp3$/i, '.wav').replace(/\.mp4$/i, '.wav');
            await ffmpeg.writeFile(file.name, new Uint8Array(await file.arrayBuffer()));
            // FFmpeg args for normalization, optional high-pass, and strip metadata
            const args = ['-i', file.name, '-vn', '-ar', '44100', '-ac', '1', '-map_metadata', '-1'];
            if (renameHighPassCheckbox.checked) {
              // Apply three cascaded high-pass filters at 100 Hz
              args.push('-af', 'highpass=f=100,highpass=f=100,highpass=f=100,volume=5dB');
            }
            args.push(tempName);
            await ffmpeg.exec(args);
            const outData = await ffmpeg.readFile(tempName);
            const newName = tempName.replace(/_tmp\.wav$/, '.wav');
            const newFile = new File([outData.buffer], newName, { type: 'audio/wav' });
            // Preserve original relative path for logging
            newFile._original = originalPath;
            // Also set webkitRelativePath for consistency
            newFile.webkitRelativePath = originalPath.replace(/\.[^\.]+$/, '.wav');
            processedFiles.push(newFile);
            await ffmpeg.deleteFile(file.name);
            await ffmpeg.deleteFile(tempName);
          } else {
            processedFiles.push(file);
          }
        }
        files = processedFiles;

        // Pre-process extras, tracks, and non-wavs
        let coreFiles = await handleExtrasAndTracks(files, zip, log, conversionLogEntries, rootFolderName);

        // Board-specific logic
        const src = sourceBoardEl.value.toUpperCase();
        const tgt = targetBoardEl.value.toUpperCase();

        if (src === "PROFFIE" && tgt === "PROFFIE") {
          await fat32ProffieOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
        if (tgt === "CFX") {
          await CFXOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
        if (tgt === "VERSO") {
          await VERSOOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
        if (tgt === "GOLDEN_HARVEST") {
          await GHOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
        if (tgt === "XENO3") {
          await XENO3Organizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
        if (tgt === "PROFFIE") {
          await fat32ProffieOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
      });



    // Audio‑Only modal behavior
    const audioOnlyButton = document.getElementById('audioOnlyButton');
    const audioOnlyWindow = document.getElementById('audioOnlyWindow');
    const audioCloseButton = document.getElementById('audioCloseButton');

    audioOnlyButton.addEventListener('click', () => {
      // Hide main log when showing audio modal
      logEl.style.display = 'none';
      audioOnlyWindow.classList.add('visible');
    });
    audioCloseButton.addEventListener('click', () => {
      audioOnlyWindow.classList.remove('visible');
      // Restore main log when closing audio modal
      logEl.style.display = '';
    });

    // Define audio-only log helpers (after FFmpegWASM loaded)
    const audioLogEl = document.getElementById('audioLog');

    // Show "Ready to audio convert" on file selection
    const audioInput = document.getElementById('audioInput');
    audioInput.addEventListener('change', () => {
      // Clear previous messages and show ready info
      audioLogEl.innerHTML = '';
      const folderName = audioInput.files[0]?.webkitRelativePath.split('/')[0] || 'selected';
      universalLog(audioLogEl,`<span style="color:#99fff5; font-weight:bold">Ready to Convert Audio-Only - ${folderName}...</span>`);
      // Log high-pass readiness if checked
      const audioHighPassCheckbox = document.getElementById('audioHigh');
      if (audioHighPassCheckbox.checked) logHighPass(audioLogEl, true);
    });

    // Audio-only modal high-pass checkbox logging
    const audioHighPassCheckbox = document.getElementById('audioHigh');
    audioHighPassCheckbox.addEventListener('change', () => {
      removeHighPassNote();
        if (audioHighPassCheckbox.checked) logHighPass(audioLogEl, true);
    });

    // FFmpeg‑wasm initialization and conversion logic
    document.getElementById('convertAudioButton').addEventListener('click', async () => {
      // Grab high-pass checkbox locally to avoid TDZ issues
      const audioHighPassCheckbox = document.getElementById('audioHigh');
      try {
        audioLogEl.innerHTML = "";
        // Re-add header line showing folder name
        const folderName = document.getElementById('audioInput').files[0]?.webkitRelativePath.split('/')[0] || 'selected';
        universalLog(audioLogEl,`<span style="color:#99fff5; font-weight:bold">Converting Audio-Only - ${folderName}...</span>`);
        // Log high-pass status visibly and for zipped log if enabled
        if (audioHighPassCheckbox.checked) {
          universalLog(audioLogEl, "High-Pass filtering enabled.", "info", "high-pass-enabled");
        }

        // Add blank line before any moved/converted file logs
        universalLog(audioLogEl, "", "default");
        // Patch: Set corePath to ffmpeg/ffmpeg-core.js so FFmpegWASM finds the WASM binary
        const ffmpeg = new FFmpeg({
          log: true,
          corePath: './ffmpeg/ffmpeg-core.js'
        });
        await ffmpeg.load();
        // Create the zip object immediately after ffmpeg.load()
        const zip = new JSZip();

        // Gather files, skipping hidden dotfiles (do not log dotfiles)
        const allFiles = Array.from(document.getElementById('audioInput').files)
          .filter(file => !file.name.startsWith('.'));
        // Support WAV and MP3 files
        const audioFiles = allFiles.filter(file => {
          const lower = file.name.toLowerCase();
          return lower.endsWith('.wav') || lower.endsWith('.mp3');
        });

        // Compute folder suffix and root folder for zip
        const audioHPSuffix = audioHighPassCheckbox.checked ? '_HP' : '';
        const baseFolder = document.getElementById('audioInput').files[0]?.webkitRelativePath.split('/')[0] || 'selected';
        const rootZipFolder = `${baseFolder}${audioHPSuffix}`;

        // Log and zip non-audio files (e.g., images, txt), using full relative path
        allFiles.forEach(file => {
          const lower = file.name.toLowerCase();
          if (!lower.endsWith('.wav') && !lower.endsWith('.mp3')) {
            const rel = file.webkitRelativePath;
            universalLog(audioLogEl,
              '<span style="color:#99fff5">- Moved non-audio file:</span> ' +
              `<span style="color:#fff">${rel}</span> ` +
              '<span style="color:#ff0">→</span> ' +
              `<span style="color:#9f6">${rel}</span>`
            );
            zip.file(`${rootZipFolder}/${rel}`, file);
          }
        });
        if (!audioFiles.length) {
          universalLog(audioLogEl,'<span style="color:#99fff5">Audio-Only: No audio files selected</span>');
          return;
        }

        // Audio conversion logic: handle WAV and MP3 files
        for (const file of audioFiles) {
          try {
            const lower = file.name.toLowerCase();

            // MP3 Files: Convert MP3 to WAV and log both conversion and High-Pass if enabled
            if (lower.endsWith('.mp3')) {
              const rel = file.webkitRelativePath;
              const outRel = rel.replace(/\.mp3$/i, '.wav');
              const zipPath = `${rootZipFolder}/${outRel}`;
              // Run normalization without automatic log
              await normalizeAndZipAudio({
                file,
                ffmpeg,
                zip,
                zipPath,
                audioHighPass: audioHighPassCheckbox.checked,
                logFn: (msg, type = "info") => universalLog(audioLogEl, msg, type),
                suppressConversionLog: true
              });
              // Manually log conversion
              universalLog(audioLogEl,
                '<span style="color:#99fff5; font-weight:bold">Audio converted:</span> ' +
                `<span style="color:#fff">${rel}</span> ` +
                '<span style="color:#ff0">→</span> ' +
                `<span style="color:#9f6">${zipPath}</span>`
              );
              // Print high-pass log line if enabled
              if (audioHighPassCheckbox.checked) {
                universalLog(audioLogEl,
                  '<span style="color:#99fff5; font-weight:bold">Audio (high-pass):</span> ' +
                  `<span style="color:#fff">${outRel}</span> → applied high-pass filter.`
                );
              }
              continue;
            }

            // WAV Files: Inspect header for sample rate/bit depth
            const arrayBuffer = await file.arrayBuffer();
            const view = new DataView(arrayBuffer);
            const sampleRate = view.getUint32(24, true);
            const bitsPerSample = view.getUint16(34, true);
            // Compute zip path: preserve folder structure after root, but always under rootZipFolder
            const relPath = file.webkitRelativePath.split('/').slice(1).join('/');
            const zipPath = `${rootZipFolder}/${relPath}`;

            // -- WAV is already correct format, and High-Pass is OFF: just zip, skip conversion
            if (sampleRate === 44100 && bitsPerSample === 16 && !audioHighPassCheckbox.checked) {
              const rel = file.webkitRelativePath;
              universalLog(audioLogEl,
                '<span style="color:#99fff5; font-weight:bold">Audio:</span> ' +
                `<span style="color:#fff">${rel}</span> is already good to go.`
              );
              zip.file(zipPath, file);
              continue;
            }

            // -- WAV is already correct format, but High-Pass is ON
            if (sampleRate === 44100 && bitsPerSample === 16 && audioHighPassCheckbox.checked) {
              const rel = file.webkitRelativePath;
              universalLog(audioLogEl,
                '<span style="color:#99fff5; font-weight:bold">Audio (high-pass):</span> ' +
                `<span style="color:#fff">${rel}</span> → applied high-pass filter.`
              );
              await normalizeAndZipAudio({
                file,
                ffmpeg,
                zip,
                zipPath,
                audioHighPass: audioHighPassCheckbox.checked,
                logFn: (msg, type = "info") => universalLog(audioLogEl, msg, type),
                suppressConversionLog: true
              });
              continue;
            }

            // -- WAV is NOT correct format. Reformat to 44.1kHz, and High-Pass if enabled.
            await normalizeAndZipAudio({
              file,
              ffmpeg,
              zip,
              zipPath,
              audioHighPass: audioHighPassCheckbox.checked,
              logFn: (msg, type = "info") => universalLog(audioLogEl, msg, type)
            });
            // If high-pass is enabled, log it for files that were converted
            if (audioHighPassCheckbox.checked) {
              const rel = file.webkitRelativePath;
              universalLog(audioLogEl,
                '<span style="color:#99fff5; font-weight:bold">Audio (high-pass):</span> ' +
                `<span style="color:#fff">${rel}</span> → applied high-pass filter.`
              );
            }

          } catch (fileErr) {
            universalLog(audioLogEl,
              '<span style="color:#ffb0a5">Error processing ' +
              `<span style="color:#fff">${file.name}</span>: ${fileErr.message}</span>`
            );
          }
        }

        // Add to onscreen log:
        universalLog(audioLogEl, "", "default");
        universalLog(audioLogEl, "Audio-Only Conversion complete.", "info");
        universalLog(audioLogEl, buildFooterBanner(), "default");

        // Add to Audio-Only Conversion log by copying onscreen log entries:
        const header = buildLogHeader(
          'Audio-Only Conversion Log',
          '',
          '',
          '',
          audioHighPassCheckbox.checked
        );
        const rawLines = Array.from(audioLogEl.querySelectorAll('div')).map(div => div.textContent.trim());
        const body = '\n' + rawLines.join('\n') + '\n';
        zip.file(`${rootZipFolder}/_Audio_Conversion_Log.txt`, header + body);

      // Zip Converted files up
        const blob = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `Converted_Audio_${folderName}${audioHPSuffix}.zip`;
        document.body.appendChild(link);
        link.click();
        link.remove();
      } catch (e) {
        universalLog(audioLogEl,'Audio conversion failed: ' + e.message);
      }
    });
  </script>
</body>
</html>

<!--
814.ffmpeg.js
-->

