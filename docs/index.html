<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/png" href="favicon.png">
  <title>SoundFontNamingConverter (Browser-based)</title>
  <link rel="stylesheet" href="cleaned_styles.css">
</head>
<body>
  <div id="popup" class="popup">
    <button id="popupCloseButton" class="close-button">&#10006;</button>
        <label class="dont-show-label">
            <input type="checkbox" id="dontShowAgain">
            <span>Don't show this on page load</span>
        </label>
    <div id="popupContent">
        <h2>Version Changelog</h2>

        <p>[5.0.0]<br>
          <strong>Version 5: Browser-Based Lightning Speed!</strong><br>
          &bull; <strong>Brand new browser-based converter:</strong> No files are uploaded! Everything is processed instantly in your browser with NO lag, NO waiting on slow servers, and no limits to how many users can run it at once.<br>
          <br>
          &bull; <strong>NEW UI!</strong> Streamlined interface makes getting around and getting your results faster than ever. Output logs are bigger, color-coded, and much easier to read, and downloads are automatically triggered.<br>
          <br>
          &bull; <strong>All your favorite features are here:</strong><br>
          &nbsp;&nbsp;&ndash; Board-specific renaming: Handles Proffie, CFX, Golden Harvest, Verso, and Xeno3, including special rules for CFX mixed numbered/unnumbered files, Xeno parenthesis, auto-inclusion of Verso blaster sound, Golden Harvest and Proffie settings files, and more.<br>
          &nbsp;&nbsp;&ndash; <strong>Multiple fonts at once:</strong> Process tons of subfolders in one go, and it‚Äôs FAST!<br>
          &nbsp;&nbsp;&ndash; <strong>Proffie font optimization:</strong> Instantly organizes fonts for best FAT32 SD card performance, automatically applied any time Proffieboard is the target. Includes correctly organizing file structure, wrangling loose files from root, etc...<br>
          &nbsp;&nbsp;&ndash; <strong>Auto-Audio Conversion:</strong> Renaming automatically converts mis-formatted wavs, converts mp3's, and strips metadata from audio files. Sweet!<br>
          &nbsp;&nbsp;&ndash; <strong>Audio-only conversion:</strong> Converts WAV and MP3 files to 44.1kHz, 16-bit mono (no renaming, just pure conversion for soundboard compatibility).<br>
          &nbsp;&nbsp;&ndash; <strong>High-pass filtering option:</strong> Make sure your fonts sound clean on small saber speakers.<br>
          &nbsp;&nbsp;&ndash; <strong>Conversion logs provided with every conversion:</strong> Keep a clear record of everything that happened, included in your download.<br>
          <br>
          &bull; <strong>Bonus:</strong> Quick links to the best saber sites, right in the footer.<br>
          <br>
          &bull; <strong>Please consider the Buy Me A Coffee link below if this tool helped you out. This was a lot of work üòâ</strong>
          <div style="text-align:center; margin-top:0.5em;">
            <strong>Thank you! ‚òï</strong>
          </div>
        </p>

        <p>[4.3.4]<br>
        <strong>Fixed</strong><br>
        &bull; Fixed mp3 conversion bug.<br>
        &bull; Fixed high-pass bug.<br>
        </p>

        <p>[4.3.3]<br>
        <strong>Fixed</strong><br>
        &bull; Fixed logging for Audio Conversion.<br>
        </p>

        <p>[4.3.2]<br>
        <strong>Fixed</strong><br>
        &bull; Fixed Sample Rate conversion error.<br>
        </p>

        <p>[4.3.1]<br>
        <strong>Added</strong><br>
        &bull; Version Changelog popup.<br>
        &bull; BC Style Editor link in Other Sites section.<br>
        </p>

        <p>[4.3.0]<br>
        <strong>Added</strong><br>
        &bull; Dedicated Golden Harvest naming instead of suggesting to just use CFX naming.<br>
        &bull; Add Golden Harvest settings.txt to the font folder in the process.<br>
        &bull; Timestamp to Conversion_log.txt.<br>
        <strong>Changed</strong><br>
        &bull; Changed GH3 to just Golden Harvest, as there‚Äôs now a GH4 as well that uses the same convention.<br>
        &bull; Changed board dropdown menus to mixed instead of all CAPS.<br>
        &bull; Changed ‚ÄúConvert‚Äù to ‚ÄúRename‚Äù throughout, except Convert Audio, because that is actual conversion.<br>
        &bull; Verso: Changed any extra font files to fontALT instead of boot files.<br>
        <strong>Fixed</strong><br>
        &bull; Fixed status text that wasn‚Äôt showing the source font folder name.<br>
        &bull; Fixed Semantic Versioning of this project!<br>
        </p>

        <p>[4.2.1]<br>
        <strong>Fixed</strong><br>
        &bull; Fixed optimization checkbox hover tips.<br>
        </p>

        <p>[4.2.0]<br>
        <strong>Added</strong><br>
        &bull; Optional Enable High Pass filter to both renaming and audio convert only routines.<br>
        &bull; Automatically apply 40 sample fade-in and fade-out to front and end of WAVs to prevent clicking.<br>
        &bull; Automatically scroll to bottom to reveal Download button when ready.<br>
        </p>

        <p>[4.1.1]<br>
        <strong>Added</strong><br>
        &bull; Metadata tags are automatically removed (Artist, Title, Genre etc...)<br>
        </p>

        <p>[4.1.0]<br>
        <strong>Added</strong><br>
        &bull; Support for mp4 video files!<br>
        &nbsp;&nbsp; Audio will be grabbed from video files and converted to ideal .wav format as well.<br>
        &bull; Specific Golden Harvest naming fixes.<br>
        &bull; CFX results now properly do not number the first blaster.wav file.<br>
        &bull; Tracks, extras, bonus etc‚Ä¶ files no longer changed to all lowercase.<br>
        &bull; Verso 2.0 support - also add blast1.wav for blaster firing sound.<br>

        <p>[4.0.0]<br>
        <strong>Added</strong><br>
        &bull; Support for .mp3 files. They will be converted to ideal .wav format.<br>
        &bull; Stand-alone audio converter without renaming or restructuring anything with the "Convert Audio Only" button up top.<br>
        &nbsp;&nbsp; Download starts automatically when finished.<br>
        &bull; "Multiple Fonts" checkbox allows for selecting a folder of font folders to be processed.<br>
        &nbsp;&nbsp; This applies automatically to Audio Only conversions.<br>
        &bull; Proffie: Support for Alt, sub-sub, and "tr" sounds.<br>
        <strong>Changed</strong><br>
        &bull; File chooser interface customized to reflect when available / unavailable, with chosen folder details shown.<br>
        <strong>Fixed</strong><br>
        &bull; Better handling of tracks, "extra" or "bonus" material.<br>
        &bull; Improved logging.<br>
        </p>

        <p>[3.1.0]<br>
        <strong>Added</strong><br>
        &bull; Audio is automatically checked and converted to proper specs if needed. (44.1kHz, 16bit, monaural .wav file)<br>
        &bull; Add multiple download slots to allow for concurrent users.<br>
        &bull; Remove uploaded and zipped files after 3 minutes instead of at next conversion.<br>
        &bull; Processed files are sorted in expected order to retain same file numbers on output.<br>
        &bull; Downloaded font folder is labeled as font_board (so like Dooku_PROFFIE) to avoid mixing your fonts up.<br>
        &bull; GUI improvements:<br>
        &nbsp;&nbsp; Live, scrollable log view of conversion process.<br>
        &nbsp;&nbsp; Log output is written to a Conversion Log and is included with the converted font.<br>
        &nbsp;&nbsp; Separate upload and progress bars just because.<br>
        <strong>Changed</strong><br>
        &bull; Proffie Optimizer button hidden when not applicable.<br>
        &bull; GUI improvements:<br>
        &nbsp;&nbsp; Convert button shows availability with red or green. Larger too.<br>
        &nbsp;&nbsp; Larger, colorful download button is removed when download expires.<br>
        &nbsp;&nbsp; Dynamic Download button text.<br>
        &nbsp;&nbsp; More informative progress bar text including font name, source and target board, upload and download status, and error messages.<br>
        &nbsp;&nbsp; Tool tip changes depending on Optimize for Proffie checkbox enabled or not.<br>
        </p>

        <p>[3.0.0]<br>
        <strong>Added</strong><br>
        &bull; Proffie: Adds missing default config.ini and smoothsw.ini files.<br>
        </p>
    </div>
  </div>

  <h1>SoundFontNamingConverter MVP <span style="color:#fff;font-size:0.62em;">  Version 5.0 </span></h1>

  <p style="text-align:center;margin-bottom:0.7em;">1. Choose a source and target format from the drop down menus below.</p>
  <form id="optionsForm" onsubmit="return false;">
    <select id="sourceBoard" name="sourceBoard" title="Source board">
      <option value="CFX">CFX</option>
      <option value="GOLDEN_HARVEST">Golden Harvest</option>
      <option value="PROFFIE">Proffieboard</option>
      <option value="VERSO">Verso</option>
      <option value="XENO3">Xeno 3</option>
    </select>
    <select id="targetBoard" name="targetBoard" title="Target board">
      <option value="CFX">CFX</option>
      <option value="GOLDEN_HARVEST">Golden Harvest</option>
      <option value="PROFFIE">Proffieboard</option>
      <option value="VERSO">Verso</option>
      <option value="XENO3">Xeno 3</option>
    </select>
  </form>
  <p class="select-label">2. Select a folder of sound font files:</p>
  <div class="files-chooser-row">
    <input type="file" id="folderInput" webkitdirectory multiple class="file-input">
  </div>
  <div id="multipleFontsCheckboxContainer" class="multiple-fonts-row">
    <input type="checkbox" id="multipleFontsCheckbox" name="multipleFontsCheckbox" class="multiple-fonts-checkbox">
    <label for="multipleFontsCheckbox" class="multiple-fonts-label">
      Multiple Fonts
      <span class="multiple-fonts-desc">(process each subfolder as a separate font)</span>
    </label>
  </div>
  <div class="rename-highpass-row">
    <input type="checkbox" id="mainHighPass" class="rename-highpass-checkbox">
    <label for="mainHighPass" class="rename-highpass-label">
      Enable High-Pass Filter
    </label>
  </div>
  <div class="rename-button-row">
    <button id="renameBtn" disabled>Rename & Download Zip</button>
  </div>
  <!-- Audio‚ÄëOnly Conversion Trigger -->
  <div class="audio-only-container">
    <button type="button" id="audioOnlyButton" class="audio-only-button">Convert Audio Only</button>
  </div>
  <div id="log"></div>
  <div class="footer-container">
    <span class="footer-title">NoSloppy - 2025</span>
    <button id="versionChangelogButton" class="footer-button" title="View the version changelog" type="button">Version Changelog</button>
    <a href="https://www.buymeacoffee.com/BrianConner" title="Brian Conner supports the saber community. Support him back.">
      <img class="donate-button" src="donateButton.jpg" alt="Buy me a coffee"></a>
    <span class="footer-links">
      <span class="other-sites">Other sites:</span>
      <a href="https://nosloppy.github.io/ProffieOS-StyleEditor-1/style_editor_BC_V6.html" target="_blank" title="BC Style Editor"><img src="https://nosloppy.github.io/ProffieOS-StyleEditor-1/SE_Favicon.png" alt="BC Style Editor logo"></a>
      <a href="https://crucible.hubbe.net/" target="_blank" title="The Crucible"><img src="https://crucible.hubbe.net/uploads/default/optimized/1X/2237f551ca8f4f69ac478df5c64aee1c951c33f5_2_180x180.png" alt="Crucible logo"></a>
      <a href="https://pod.hubbe.net/" target="_blank" title="ProffieOS Documentation site"><img src="https://pod.hubbe.net/images/favicon.png" alt="Pod logo"></a>
      <a href="https://fredrik.hubbe.net/lightsaber/" target="_blank" title="Profezzorn's Proffieboard site"><img src="https://fredrik.hubbe.net/favicon.ico" alt="Lightsaber logo"></a>
      <a href="https://www.fett263.com/" target="_blank" title="Fett263's Style Library"><img src="https://www.fett263.com/favicon.ico" alt="Fett263 logo"></a>
      <a href="https://www.facebook.com/groups/opensourcesabers/" target="_blank" title="Open Source Group"><img src="https://www.facebook.com/favicon.ico" alt="Facebook logo"></a>
      <a href="https://crystalfocus.net/" target="_blank" title="crystalfocus.net"><img src="https://crystalfocus.net/images/logo.ico" alt="crystalfocus.net logo"></a>
      <a href="https://sabertec.net/" target="_blank" title="sabertec.net"><img src="https://sabertec.net/wp-content/uploads/2016/12/cropped-Logo-Sabertec-Bildmarke-V2-Hintergrund-32x32.png" alt="sabertec.net logo"></a>
      <a href="https://darkwolfsabers.com/" target="_blank" title="darkwolfsabers.com"><img src="https://img1.wsimg.com/isteam/ip/494b9647-5ed3-4359-92d3-188572d6d1f1/favicon/95b2b868-5641-4853-8c6d-057e8ebf1d55.jpeg/:/rs=w:16,h:16,m" alt="darkwolfsabers.com logo"></a>
    </span>
  </div>

  <!-- Load local UMD FFmpeg wrapper -->
  <script src="./ffmpeg/ffmpeg.js"></script>
  <script>
    // UMD exposes FFmpegWASM global
    if (!window.FFmpegWASM || typeof FFmpegWASM.FFmpeg !== 'function') {
      console.error('Local UMD FFmpegWASM failed to load; FFmpeg class is undefined.');
    } else {
      console.log('Local UMD FFmpegWASM loaded:', FFmpegWASM);
    }
    const { FFmpeg } = FFmpegWASM;
  </script>
  <div id="audioOnlyWindow" class="audio-only-window">
    <button type="button" id="audioCloseButton" class="close-button">&#10006;</button>
    <h2 class="centered-header">Convert to 44.1‚ÄØkHz 16‚Äëbit mono WAV</h2>
    <div style="margin:1em 0;">
      <input type="file" id="audioInput" webkitdirectory multiple>
    </div>
    <div style="margin-bottom:1em;">
      <label><input type="checkbox" id="audioHigh"> Enable High‚ÄëPass Filter</label>
    </div>
    <div id="audioLog" style="margin-top:1em; width:100%; flex:1; overflow:auto; background:#23272b; padding:0.8em; color:#e2e2e2; font-family:'Fira Mono', monospace; font-size:0.95em; border-radius:0.4em;"></div>
    <button type="button" id="convertAudioButton" class="convert-audio-button">Convert Audio & Download Zip</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    console.log("HELLO FROM TOP OF SCRIPT");
    // Mapping CSV URLs for every board combo
    const CSV_URLS = {
      "CFX_TO_PROFFIE":             "CSV/CFX_TO_PROFFIE.csv",
      "GOLDEN_HARVEST_TO_PROFFIE":   "CSV/GOLDEN_HARVEST_TO_PROFFIE.csv",
      "PROFFIE_TO_CFX":             "CSV/PROFFIE_TO_CFX.csv",
      "PROFFIE_TO_GOLDEN_HARVEST":  "CSV/PROFFIE_TO_GOLDEN_HARVEST.csv",
      "PROFFIE_TO_VERSO":           "CSV/PROFFIE_TO_VERSO.csv",
      "PROFFIE_TO_XENO3":           "CSV/PROFFIE_TO_XENO3.csv",
      "VERSO_TO_PROFFIE":           "CSV/VERSO_TO_PROFFIE.csv",
      "XENO3_TO_PROFFIE":           "CSV/XENO3_TO_PROFFIE.csv"
    };

    // === DOM ===
    const logEl = document.getElementById('log');
    const folderInput = document.getElementById('folderInput');
    const sourceBoardEl = document.getElementById('sourceBoard');
    const targetBoardEl = document.getElementById('targetBoard');
    const renameBtn = document.getElementById('renameBtn');
    const renameHighPassCheckbox = document.getElementById('mainHighPass');
    const multipleFontsCheckbox = document.getElementById('multipleFontsCheckbox');

    // === State ===
    let files = [];
    let originalFiles = [];
    let mapping = {};
    let mappingReady = false;
    let conversionLogEntries = [];

    // Track recognition: Load known_tracks.txt from the same directory as index.html
    let knownTracksSet = new Set();

    async function loadKnownTracks() {
      try {
        const resp = await fetch('known_tracks.txt');
        if (!resp.ok) throw new Error("Failed to fetch");
        const txt = await resp.text();
        knownTracksSet = new Set(txt.split(/\r?\n/).map(l => l.trim().toLowerCase()).filter(Boolean));
        console.log("Loaded known tracks:", knownTracksSet);
      } catch (err) {
        console.log("Could not load known_tracks.txt:", err);
        knownTracksSet = new Set();
      }
    }
    loadKnownTracks();

    // Logging
    function universalLog(el, msg, type = "default", className = "", afterFirst = false) {
      const colors = {
        info: "#99fff5",
        error: "#ffb0a5",
        success: "#9f6",
        default: "#e2e2e2"
      };

      const safeType = (type || "default").toLowerCase();
      const color = colors[safeType] || colors.default;

      const entry = document.createElement('div');
      entry.innerHTML = `<span style="color:${color}">${msg}</span>`;
      if (className) entry.classList.add(className);

      if (afterFirst && el.children.length > 1) {
        el.insertBefore(entry, el.children[1]);
      } else {
        el.appendChild(entry);
      }

      // Only add <br> if explicitly asked (e.g., msg === "")
      if (msg === "") {
        const br = document.createElement('br');
        if (className) br.classList.add(className);
        if (afterFirst && el.children.length > 2) {
          el.insertBefore(br, el.children[2]);
        } else {
          el.appendChild(br);
        }
      }
      if (el === logEl || el === audioLogEl) {
        if (afterFirst) {
          el.scrollTop = 0; // Scroll to top if we just inserted high-pass line
        } else {
          el.scrollTop = el.scrollHeight;
        }
      }
    }

    function logHighPass(el, afterFirst = false) {
      // Remove any existing High-Pass log lines
      document.querySelectorAll('.high-pass-enabled').forEach(el => {
        const next = el.nextSibling;
        el.remove();
        if (next && next.nodeName === 'BR') next.remove();
      });
      universalLog(el, "High-Pass filtering enabled.", "info", "high-pass-enabled", afterFirst);
    }

    function clearLog() {
      logEl.innerHTML = "";
      document.body.style.overflow = "clip";
      document.body.style.paddingBottom = "0";
    }

    function removeHighPassNote() {
      document.querySelectorAll('.high-pass-enabled').forEach(el => {
        const next = el.nextSibling;
        el.remove();
        if (next && next.nodeName === 'BR') next.remove();
      });
    }

    // Parse CSV (mapping) text into an object
    function parseCSV(csv) {
      const lines = csv.split(/\r?\n/);
      const map = {};
      for (const line of lines) {
        if (!line.trim()) continue;
        const [orig, renamed] = line.split(',').map(x => x.trim());
        if (orig && renamed) map[orig.toLowerCase()] = renamed;
      }
      return map;
    }

    function buildReverseMap(forwardMap) {
      const reverse = {};
      for (const [k, v] of Object.entries(forwardMap)) {
        if (!reverse[v]) reverse[v] = k;
      }
      return reverse;
    }

    // === Utility: single call to add to zip, conversionLogEntries, and log in one go ===
    function addZipEntry(zip, file, zipPath, label = 'Renamed') {
      zip.file(zipPath, file);
      // Determine source path: prefer original snapshot, fallback to webkitRelativePath
      const srcPath = file._original || file.webkitRelativePath;
      // Push to conversion log (normalize arrow)
      conversionLogEntries.push(`${label}: ${srcPath} -> ${zipPath}`);
      // Colorized on-screen log: white source, yellow arrow, green target
     universalLog(logEl,`Renamed: <span style="color:#fff">${srcPath}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipPath}</span>`);
    }

    // === Utility: unified track detection ===
    function isTrackFile(file) {
      const name = file.name.toLowerCase();
      const parts = file.webkitRelativePath.toLowerCase().split('/');
      return knownTracksSet.has(name)
          || parts.includes('tracks')
          || /(track|theme|song|music)/.test(name);
    }

    // Helper: Load direct or reverse mapping as object
    async function getMappingObj(csvKey, reverse = false) {
      const csv = await (await fetch(CSV_URLS[csvKey])).text();
      const obj = parseCSV(csv);
      return reverse ? buildReverseMap(obj) : obj;
    }

    // Combine reverse-of-first + direct second mapping in one call
    async function loadBidirectionalMapping(revKey, directKey) {
      const forward = await getMappingObj(revKey);
      const reverse = buildReverseMap(forward);
      const direct  = await getMappingObj(directKey);
      return { ...reverse, ...direct };
    }

    // === Log header/footer helpers ===
    function buildLogHeader(modeLabel, src, tgt, baseName) {
      let hdr =
        '------------------------------------------------\n' +
        'Renamed with SoundFontNamingConverter V5\n' +
        'Brian Conner a.k.a NoSloppy\n' +
        modeLabel + '\n' +
        new Date().toLocaleString() + '\n';
      hdr += '------------------------------------------------\n';
      return hdr;
    }

    // Unified banner helpers for logs and onscreen

    function buildFooterBanner() {
      return '<span style="color:#ffe066;font-weight:bold;">------------------ | **** MTFBWY **** | ------------------</span>';
    }

    // Helper to prompt user to select files for a renaming set
    function promptSelectFiles(src, tgt) {
      mappingReady = true;
     universalLog(logEl,`${src} ‚Üí ${tgt} renaming set, please choose files above.`, "info");
      // Sync high-pass message
      document.querySelectorAll('.high-pass-enabled').forEach(el => {
        const next = el.nextSibling;
        el.remove();
        if (next && next.nodeName === 'BR') next.remove();
      });
      if (renameHighPassCheckbox.checked) {
        logHighPass(logEl, true);
        logEl.scrollTop = 0; // Scroll to top so message is visible
      }
      folderInput.disabled = false;
    }

    // Helper: finalize zip, build log, trigger download, and UI reset
    function finalizeAndDownload(src, tgt, zip, rootFolderName, fontFolderName = "") {
      // Build header via unified helper
      const baseName = files[0]._original.split('/')[0];
      const header = buildLogHeader(
        'Font Renaming Log',
        src,
        tgt,
        baseName,
        renameHighPassCheckbox.checked
      );
      // Prepend the conversion header lines to the body
      const preBodyLines = [];
      preBodyLines.push(`Renaming: ${baseName} from ${src} to ${tgt}.`);
      if (renameHighPassCheckbox.checked) {
        preBodyLines.push('High-Pass filtering enabled.');
      }
      preBodyLines.push('');  // blank line after header lines
      // Build full body including CFX footnotes
      let bodyLines = [...preBodyLines, ...conversionLogEntries];
      if (tgt === 'CFX') {
        const pwroffCount = conversionLogEntries.filter(line => line.includes('pwroff2.wav')).length;
        if (pwroffCount >= 1) {
          const note1 = '-- CFX requires a "pwroff2" file for retractions when blade is moving.';
          const note2 = '-- So if only a single RETRACTION sound is received, it is made into both "poweroff" and "pwroff2" to fulfill the requirement.';
          bodyLines.push(note1, note2);
         universalLog(logEl,note1, 'info');
         universalLog(logEl,note2, 'info');
        }
        if (pwroffCount >= 2) {
          const note3 = '-- If a second RETRACTION sound comes through, then it is used for "pwroff2" instead, replacing the first instance.';
          const note4 = '-- Any additional RETRACTION sounds are then made as continued sequential "poweroff"s';
          bodyLines.push(note3, note4);
         universalLog(logEl,note3, 'info');
         universalLog(logEl,note4, 'info');
        }
      }
      // Build the file log by copying onscreen log entries:
      universalLog(logEl, "", "default");
      universalLog(logEl, `Renaming from ${src} ‚Üí ${tgt} complete.`, "info");
      universalLog(logEl, buildFooterBanner(), "default");

      // Add to Audio-Only Conversion log:
      const rawLines = Array.from(logEl.querySelectorAll('div')).map(div => div.textContent.trim());
      const body = '\n' + rawLines.join('\n') + '\n';
      const logText = header + body;
      zip.file(`${rootFolderName}/_Conversion_Log.txt`, logText);

      // Zip Renamed files up
      zip.generateAsync({ type: 'blob' }).then(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const mainHpSuffix = renameHighPassCheckbox.checked ? '_HP' : '';
        let fontSuffix = fontFolderName ? ("_" + fontFolderName) : "";
        a.download = `Renamed_${src}_to_${tgt}${fontSuffix}${mainHpSuffix}.zip`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => {
          universalLog(logEl, "<br><br>");
          renameBtn.disabled = false;
        }, 50);
      });
    }

    /**
     * Pre-processes files to handle non-wav, track, and extras files uniformly.
     * Moves handled files into the zip and returns only the core wav files for board-specific logic.
     */
    async function handleExtrasAndTracks(files, zip, log, conversionLogEntries, rootFolderName) {
      const remaining = [];
      const root = rootFolderName;
      for (const file of files) {
        if (file.name.startsWith('.')) continue;
        const nameLower = file.name.toLowerCase();
        // Use the preserved original path for logging when available
        const rel = file._original || file.webkitRelativePath;
        // 1) Non-wav files: copy any non-wav (e.g., .ini, .bmp) to root
        if (!nameLower.endsWith('.wav')) {
          const zipPath = `${root}/${file.name}`;
          zip.file(zipPath, file);
         universalLog(logEl,`<span style="color:#99fff5">- Moved non-wav file:</span> <span style="color:#fff">${rel}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipPath}</span>`);
          conversionLogEntries.push(`- Moved non-wav file ${rel} ‚Üí ${zipPath}`);
          continue;
        }
        // 2) Track files: unified detection
        if (isTrackFile(file)) {
          const zipPath = `${root}/tracks/${file.name}`;
         universalLog(logEl,'(‚åê‚ñ†_‚ñ†) This looks like a track file.', 'info');
          zip.file(zipPath, file);
         universalLog(logEl,`<span style="color:#99fff5">- Moved track file:</span> <span style="color:#fff">${rel}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipPath}</span>`);
          conversionLogEntries.push(`- Moved track file: ${rel} ‚Üí ${zipPath}`);
          continue;
        }
        // 3) Extras/bonus folders
        const parts = rel.split('/');
        const idx = parts.map(p => p.toLowerCase()).findIndex(p => /(extra|xtra|bonus)/.test(p));
        if (idx !== -1) {
          const sub = parts.slice(idx + 1).join('/');
          const zipPath = `${root}/extras${sub ? '/' + sub : ''}`;
          zip.file(zipPath, file);
         universalLog(logEl,`<span style="color:#99fff5">- Moved extra or bonus file:</span> <span style="color:#fff">${rel}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipPath}</span>`);
          conversionLogEntries.push(`- Moved extra or bonus file: ${rel} ‚Üí ${zipPath}`);
          continue;
        }
        // Otherwise, leave for board-specific processing
        remaining.push(file);
      }
      return remaining;
    }

    // Load CSV mapping as soon as both dropdowns are selected
    async function autoSelectAndLoadMapping() {
      // Reset UI
      mappingReady = false;
      renameBtn.textContent = 'Rename & Download Zip';
      renameBtn.disabled = true;
      folderInput.disabled = true;
      clearLog();
      showMultipleFontsExplainer();
      const src = sourceBoardEl.value;
      const tgt = targetBoardEl.value;

      // Case 1: identical boards
      if (src === tgt) {
        if (src === "PROFFIE") {
         universalLog(logEl,"Proffieboard to Proffieboard organizes and renames a ProffieOS sound font for best FAT32 performance.", "info");
          mapping = {};
          mappingReady = true;
          folderInput.disabled = false;
          checkReady();
          // Add high-pass message if enabled
          if (renameHighPassCheckbox.checked) logHighPass(logEl, true);
        } else {
         universalLog(logEl,`Renaming from ${src} ‚Üí ${tgt} is unnecessary.`, "info");
        }
        return;
      }

      // Case 2: chained conversion (neither PROFFIE)
      if (src !== "PROFFIE" && tgt !== "PROFFIE") {
        try {
          const srcToPro = await loadBidirectionalMapping(`PROFFIE_TO_${src}`, `${src}_TO_PROFFIE`);
          const proToTgt = await getMappingObj(`PROFFIE_TO_${tgt}`);
          mapping = key => {
            const lower = key.toLowerCase();
            const mid = srcToPro[lower] || lower;
            return proToTgt[mid.toLowerCase()] || mid;
          };
          promptSelectFiles(src, tgt);
          renameHighPassCheckbox.disabled = false;
          checkReady();
        } catch (e) {
         universalLog(logEl,`Failed to set up ${src}‚Üí${tgt} chained mapping: ${e}`, "error");
        }
        return;
      }

      // Case 3: direct conversion (one end PROFFIE)
      try {
        let mapObj;
        // mapping from other‚ÜíPROFFIE
        if (tgt === "PROFFIE") {
          mapObj = await loadBidirectionalMapping(`PROFFIE_TO_${src}`, `${src}_TO_PROFFIE`);
        }
        // mapping from PROFFIE‚Üíother
        else if (src === "PROFFIE") {
          mapObj = await getMappingObj(`PROFFIE_TO_${tgt}`);
        }
        // fallback direct if CSV exists
        else {
          const key = `${src}_TO_${tgt}`;
          mapObj = CSV_URLS[key] ? await getMappingObj(key) : {};
        }
        mapping = mapObj;
        promptSelectFiles(src, tgt);
        renameHighPassCheckbox.disabled = false;
        checkReady();
      } catch (e) {
       universalLog(logEl,`Failed to load ${src}‚Üí${tgt} mapping: ${e}`, "error");
      }
    }

    // Check if ready for renaming
    function checkReady() {
      renameBtn.disabled = !(files.length && mappingReady);
    }

    // Dropdown change handlers
    sourceBoardEl.addEventListener('change', autoSelectAndLoadMapping);
    targetBoardEl.addEventListener('change', autoSelectAndLoadMapping);
    autoSelectAndLoadMapping(); // On page load

    // Folder/file picker handler
    folderInput.addEventListener('change', (e) => {
      files = Array.from(e.target.files);
      originalFiles = Array.from(e.target.files);
      clearLog();
      showMultipleFontsExplainer();
      if (files.length) {
       universalLog(logEl,`Selected ${files.length} files from folder: <b>${files[0].webkitRelativePath.split('/')[0]}</b>`);
        if (mappingReady)universalLog(logEl,`${sourceBoardEl.value} ‚Üí ${targetBoardEl.value} renaming ready.`, "info");
        if (renameHighPassCheckbox.checked) {
         universalLog(logEl,'High-Pass filtering enabled.', 'info');
        }
      }
      checkReady();
      renameBtn.textContent = 'Rename & Download Zip';
    });


    multipleFontsCheckbox.addEventListener('change', function() {
      // Remove any old explanation lines
      document.querySelectorAll('.multiple-fonts-explainer').forEach(el => el.remove());
      if (this.checked) {
        // Insert clear explanation to the log
        universalLog(
          logEl,
          // "Multiple Fonts: Each immediate subfolder of the selected folder will be processed as an individual sound font.",
          `<span style="color:#ffe066;font-weight:bold">Multiple Fonts <span style="color:red;">ON</span>: Each immediate subfolder of the selected folder will be processed as an individual sound font.<br>
          If a folder contains multiple font folders and this is <span style="color:red;font-weight:bold">OFF</span>, all fonts within will be merged into one <span style="color:red;font-weight:bold">√ºber font</span>.</span>`,
          "default",
          "multiple-fonts-explainer",
          true  // insert after first line
        );
        logEl.scrollTop = 0;
      }
    });

    function showMultipleFontsExplainer() {
      // Only show if checked, and only if not already present
      if (multipleFontsCheckbox.checked &&
          !logEl.querySelector('.multiple-fonts-explainer')) {
        universalLog(
          logEl,
          `<span style="color:#ffe066;font-weight:bold">Multiple Fonts <span style="color:red;">ON</span>: Each immediate subfolder of the selected folder will be processed as an individual sound font.<br>
          If a folder contains multiple font folders and this is <span style="color:red;font-weight:bold">OFF</span>, all fonts within will be merged into one <span style="color:red;font-weight:bold">√ºber font</span>.</span>`,
          "default",
          "multiple-fonts-explainer",
          true
        );
        logEl.scrollTop = 0;
      }
    }

    // Rename High-Pass checkbox change logging (add/remove message as needed)
    renameHighPassCheckbox.addEventListener('change', () => {
      removeHighPassNote();
      if (renameHighPassCheckbox.checked) logHighPass(logEl, true);
    });

   async function fat32ProffieOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      // === Proffie altXXX folders support ===
      // collect any files under alt000, alt001, etc.
      const altFiles = files.filter(f => {
        const parts = f.webkitRelativePath.split('/');
        return /^alt\d{3}$/i.test(parts[1]);
      });
      if (altFiles.length) {
        // group by alt directory and by clean base name
        const altGroups = {};
        altFiles.forEach(f => {
          const parts = f.webkitRelativePath.split('/');
          const altDir = parts[1];
          const cleanName = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
          altGroups[altDir] = altGroups[altDir] || {};
          altGroups[altDir][cleanName] = altGroups[altDir][cleanName] || [];
          altGroups[altDir][cleanName].push(f);
        });
        const altDirs = Object.keys(altGroups).sort();
        // determine maximum count per base across all alt dirs
        const baseCounts = {};
        altDirs.forEach(dir => {
          Object.keys(altGroups[dir]).forEach(base => {
            baseCounts[base] = Math.max(baseCounts[base]||0, altGroups[dir][base].length);
          });
        });
        // fill missing entries by copying from any alt directory that has them
        altDirs.forEach(dir => {
          Object.entries(baseCounts).forEach(([base, count]) => {
            const arr = altGroups[dir][base] || [];
            for (let i = arr.length; i < count; i++) {
              // find first alt folder that has the file at this index
              let fileToCopy = null;
              for (const srcDir of altDirs) {
                const srcArr = altGroups[srcDir][base] || [];
                if (srcArr[i]) {
                  fileToCopy = srcArr[i];
                  break;
                }
              }
              if (fileToCopy) {
                arr.push(fileToCopy);
              }
            }
            altGroups[dir][base] = arr;
          });
        });
      // altBases: bases to process from alt groups
      const altBases = Object.keys(baseCounts);

      // incorporate stray root-level WAVs matching alt bases: distribute into each alt folder
      const strayRoot = files.filter(f => {
        const parts = f.webkitRelativePath.split('/');
        // skip files inside any altXXX folder
        if (!parts[1] || /^alt\d{3}$/i.test(parts[1])) return false;
        const clean = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        return altBases.includes(clean);
      });
      // add each stray file to every alt group
      strayRoot.forEach(f => {
        const clean = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        altDirs.forEach(dir => {
          altGroups[dir][clean].push(f);
        });
      });

      // remove altXXX files and stray root-level WAVs from main list
      files = files.filter(f => {
        const parts = f.webkitRelativePath.split('/');
        const isAltDir = /^alt\d{3}$/i.test(parts[1]);
        const clean = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        return !isAltDir && !altBases.includes(clean);
      });
      // --- handle numeric-only files: copy as-is before grouping ---
      const remainingAfterNumeric = [];
      for (const file of files) {
        if (/^\d+\.wav$/i.test(file.name)) {
          const parts = file.webkitRelativePath.split('/');
          const parent = parts[1] || '';
          const zipPath = parent
            ? `${rootFolderName}/${parent}/${file.name}`
            : `${rootFolderName}/${file.name}`;
          addZipEntry(zip, file, zipPath, 'Moved numeric file');
        } else {
          remainingAfterNumeric.push(file);
        }
      }
      files = remainingAfterNumeric;
        // now zip each alt group into its folder, numbering in sequence
        const applyMap = name => {
          const key = name.toLowerCase();
          const mapped = typeof mapping === 'function' ? mapping(key) : (mapping[key] || key);
          return mapped.replace(/\.wav$/, '');
        };
        altDirs.forEach(dir => {
          Object.entries(altGroups[dir]).forEach(([base, arr]) => {
            arr.forEach((f, idx) => {
              const mappedBase = applyMap(base);
              let outName;
              if (arr.length === 1) {
                // single per alt: no numeric suffix
                outName = `${mappedBase}.wav`;
              } else {
                // multiple: pad to two digits
                const suffix = String(idx+1).padStart(2, '0');
                outName = `${mappedBase}${suffix}.wav`;
              }
              const zipPath = `${rootFolderName}/${dir}/${outName}`;
              zip.file(zipPath, f);
              conversionLogEntries.push(`${f.webkitRelativePath} -> ${zipPath}`);
             universalLog(logEl,`Renamed: <span style="color:#fff">${f.webkitRelativePath}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipPath}</span>`);
            });
          });
        });
      }
      // If doing a Proffie‚ÜíProffie identity conversion, bypass all CSV mappings
      const isIdentityConversion = sourceBoardEl.value === 'PROFFIE' && targetBoardEl.value === 'PROFFIE';
      const applyMapping = name => {
        if (isIdentityConversion) return name;
        return typeof mapping === 'function' ? mapping(name) : (mapping[name] || name);
      };
      // Gather .wav files by base name, skip extras/bonus/track/music/etc folders for core handling
      const wavsByBase = {};
      const originals = {};
      // 1. Collect core wav files for FAT32 grouping
      for (const file of files) {
        if (file.name.startsWith('.') || !file.name.toLowerCase().endsWith('.wav')) continue;
        const nameLower = file.name.toLowerCase();
        const relParts = file.webkitRelativePath.split('/');
        let baseNameForGroup;
        if (/^\d+\.wav$/i.test(file.name) && relParts.length > 1) {
          baseNameForGroup = relParts[1].toLowerCase() + '.wav';
        } else {
          baseNameForGroup = nameLower.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        }
        const mapped = applyMapping(baseNameForGroup);
        const base = mapped.replace(/\.wav$/, '');
        wavsByBase[base] = wavsByBase[base] || [];
        wavsByBase[base].push(file);
        originals[file.name] = file.webkitRelativePath;
      }

      // 2. Handle all wavs in sorted order (for consistent numbering)
      for (const base of Object.keys(wavsByBase)) {
        let filesForBase = wavsByBase[base];
        filesForBase.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

        if (filesForBase.length === 1) {
          // Single file: strip Xeno (n) or trailing digits, map to Proffie, put in root
          let file = filesForBase[0];
          let cleanName = file.name.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav').toLowerCase();
          let mappedName = applyMapping(cleanName);
          let zipPath = `${rootFolderName}/${mappedName}`;
          addZipEntry(zip, file, zipPath);
        } else {
          // Multiples: put in subfolder, Proffie digits, mapped base name
          let file0 = filesForBase[0];
          let cleanName0 = file0.name.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav').toLowerCase();
          let mappedName0 = applyMapping(cleanName0);
          let mappedBase = mappedName0.replace(/\.wav$/, '');
          let subdir = `${rootFolderName}/${mappedBase}`;
          for (let i = 0; i < filesForBase.length; ++i) {
            let file = filesForBase[i];
            let num = i + 1;
            let useDoubleDigits = mappedBase.length <= 6;
            let useSingleDigit = mappedBase.length === 7 || mappedBase.length === 8;
            if (mappedBase === "tr") { useDoubleDigits = true; useSingleDigit = false; }
            let fileNum =
              mappedBase === "tr"
                ? String(num - 1).padStart(2, "0")
                : useDoubleDigits
                ? String(num).padStart(2, "0")
                : String(num);
            let newName = mappedBase + fileNum + ".wav";
            let zipPath = `${subdir}/${newName}`;
            addZipEntry(zip, file, zipPath);
          }
        }
      }
    }

    // --- CFX Organizer ---
    function CFXOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      const fileNameCounter = {};
      for (const file of files) {
        if (!file.name.toLowerCase().endsWith('.wav') || file.name.startsWith('.')) continue;
        // Numeric-only files: sequence by parent folder name
        if (/^\d+\.wav$/i.test(file.name)) {
          const parts = file.webkitRelativePath.split('/');
          const parent = parts.length > 1 ? parts[1] : '';
          const count = fileNameCounter[parent] || 1;
          const outName = `${parent}${count}.wav`;
          addZipEntry(zip, file, `${rootFolderName}/${outName}`);
          fileNameCounter[parent] = count + 1;
          continue;
        }
        // Map Proffie filenames to CFX names using the mapping object
        const origLower = file.name.toLowerCase();
        // Strip numeric suffixes for grouping (e.g. "boot01.wav" ‚Üí "boot.wav")
        const keyForMapping = origLower.replace(/(\d+)\.wav$/i, '.wav');
        // Apply mapping on stripped key, fallback to stripped key
        const mappedName = (typeof mapping === "function")
          ? mapping(keyForMapping)
          : (mapping[keyForMapping] || keyForMapping);
        // Derive baseKey (without extension) for duplicate counting
        const baseKey = mappedName.replace(/\.wav$/i, '');
        let counter = fileNameCounter[baseKey] || 1;
        let outName;

        switch (baseKey) {
          case "poweroff":
            if (counter === 1) {
              // First poweroff and also create pwroff2
              addZipEntry(zip, file, `${rootFolderName}/poweroff.wav`);
              addZipEntry(zip, file, `${rootFolderName}/pwroff2.wav`, 'Also create pwroff2.wav');
            } else if (counter === 2) {
              // Updated pwroff2 replacement
              addZipEntry(zip, file, `${rootFolderName}/pwroff2.wav`, 'Updated pwroff2.wav');
            } else {
              const outName = `poweroff${counter - 1}.wav`;
              addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            }
            fileNameCounter[baseKey] = counter + 1;
            break;

          case "font":
            if (counter === 1) {
              outName = "font.wav";
            } else {
             universalLog(logEl,"- CFX only uses one font file, so any additional become boots.", 'info');
              conversionLogEntries.push("- CFX only uses one font file, so any additional become boots.");
              const bootCount = fileNameCounter["boot"] || 1;
              outName = `boot${bootCount === 1 ? "" : bootCount}.wav`;
              fileNameCounter["boot"] = bootCount + 1;
            }
            addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            fileNameCounter[baseKey] = counter + 1;
            break;

          case "boot":
          case "poweron":
          case "lockup":
          case "blaster":
          case "drag":
          case "force":
          case "color":
            outName = `${baseKey}${counter === 1 ? "" : counter}.wav`;
            addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            fileNameCounter[baseKey] = counter + 1;
            break;

          default:
            outName = `${baseKey}${counter}.wav`;
            addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            fileNameCounter[baseKey] = counter + 1;
            break;
        }
      }
    }

    // --- VERSO Organizer ---
    async function VERSOOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      // Pre-group all WAVs by base name (strip numeric suffixes)
      const filesByBase = {};
      for (const file of files) {
        if (!file.name.toLowerCase().endsWith('.wav') || file.name.startsWith('.')) continue;
        const key = file.name.toLowerCase().replace(/(\d+)\.wav$/i, '.wav');
        const mapped = (typeof mapping === "function")
          ? mapping(key)
          : (mapping[key] || key);
        const base = mapped.replace(/\.wav$/i, '');
        if (!filesByBase[base]) filesByBase[base] = [];
        filesByBase[base].push(file);
      }

      // Process each group
      for (const base of Object.keys(filesByBase).sort()) {
        const group = filesByBase[base];
        group.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
        // Special handling for font: first -> font.wav, rest -> fontALT1.wav, fontALT2.wav...
        if (base === 'font') {
          for (let i = 0; i < group.length; i++) {
            const file = group[i];
            const outName = i === 0
              ? 'font.wav'
              : `fontALT${i}.wav`;
            const zipPath = `${rootFolderName}/${outName}`;
            addZipEntry(zip, file, zipPath);
          }
        } else if (group.length === 1) {
          // Single file: base1.wav (always numbered)
          const file = group[0];
          const outName = `${base}1.wav`;
          const zipPath = `${rootFolderName}/${outName}`;
          addZipEntry(zip, file, zipPath);
        } else {
          // Multiple files: name1.wav, name2.wav, ...
          for (let i = 0; i < group.length; i++) {
            const file = group[i];
            const outName = `${base}${i + 1}.wav`;
            const zipPath = `${rootFolderName}/${outName}`;
            addZipEntry(zip, file, zipPath);
          }
        }
      }

      // Add mandatory Verso blast sound
      try {
        const resp = await fetch('Verso_Blast/blast1.wav');
        if (resp.ok) {
          const blob = await resp.blob();
          const blastZip = `${rootFolderName}/blast1.wav`;
          zip.file(blastZip, blob);
          // Verso-specific explanatory log
         universalLog(logEl,"-- Verso uses a 'blaster firing' sound before the 'deflection' sound, so it's been added for you.", "info");
          conversionLogEntries.push("-- Verso uses a 'blaster firing' sound before the 'deflection' sound, so it's been added for you.");
          // Add descriptive log for Verso blast requirement
          const versoMsg = "-- Added ";
         universalLog(logEl,`${versoMsg} ‚Üí ${blastZip}`, "info");
          conversionLogEntries.push(`${versoMsg} -> ${blastZip}`);
        }
      } catch (err) {
       universalLog(logEl,"Failed to add Verso blast sound: " + err, "error");
      }
    }

    // ---GOLDEN HARVEST Organizer ---
    async function GHOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      const fileNameCounter = {};
      for (const file of files) {
        if (!file.name.toLowerCase().endsWith('.wav') || file.name.startsWith('.')) continue;
        const key = file.name.toLowerCase().replace(/(\d+)\.wav$/i, '.wav');
        const mapped = (typeof mapping === "function")
          ? mapping(key)
          : (mapping[key] || key);
        const base = mapped.replace(/\.wav$/i, '');
        let outName;
        if (base === 'font') {
          const cnt = (fileNameCounter[base] || 1);
          outName = cnt === 1 ? 'font.wav' : `fontALT${cnt-1}.wav`;
          fileNameCounter[base] = cnt + 1;
        } else {
          const cnt = (fileNameCounter[base] || 0) + 1;
          fileNameCounter[base] = cnt;
          outName = `${base}${cnt}.wav`;
        }
        const zipPath = `${rootFolderName}/${outName}`;
        addZipEntry(zip, file, zipPath);
      }
      // add settings.txt
      const resp = await fetch('GOLDEN_HARVEST_settings/settings.txt');
      if (resp.ok) {
        const blob = await resp.blob();
        const path = `${rootFolderName}/settings.txt`;
        zip.file(path, blob);
       universalLog(logEl,`-- Golden Harvest settings.txt added ‚Üí ${path}`, "info");
        conversionLogEntries.push(`- Golden Harvest settings.txt added -> ${path}`);
      }
    }

    // --- XENO3 Organizer ---
    function XENO3Organizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      const fileNameCounter = {};
      for (const file of files) {
        // skip hidden and non-wav files
        if (file.name.startsWith('.') || !file.name.toLowerCase().endsWith('.wav')) continue;
        // strip any numeric suffix or parenthesized number for mapping
        const nameLower = file.name.toLowerCase();
        const cleanName = nameLower.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        // apply mapping to cleaned name
        let mappedWav;
        if (typeof mapping === 'function') {
          mappedWav = mapping(cleanName);
        } else {
          mappedWav = mapping[cleanName] || cleanName;
        }
        // strip extension for base
        const base = mappedWav.replace(/\.wav$/i, '');
        // increment counter for Xeno3 numbering
        const count = (fileNameCounter[base] || 0) + 1;
        fileNameCounter[base] = count;
        // build output name and path
        const outName = `${base} (${count}).wav`;
        const zipPath = `${rootFolderName}/${outName}`;
        addZipEntry(zip, file, zipPath);
      }
    }

      // === Audio normalization helper ===
      /**
       * Normalize a WAV or MP3 file to 44.1kHz, 16-bit mono with optional high-pass,
       * add result into zip at the same path, and log via callback.
       */
      async function normalizeAndZipAudio({ file, ffmpeg, zip, zipPath, audioHighPass, logFn, suppressConversionLog = false }) {
        const safeLog = logFn || ((msg, type = "info") => universalLog(audioLogEl, msg, type));

        // 1. Read and write original into MEMFS
        const arrayBuffer = await file.arrayBuffer();
        const inputName = file.name;
        await ffmpeg.writeFile(inputName, new Uint8Array(arrayBuffer));

        // 2. Determine temp output name
        //    For MP3 inputs, convert directly to .wav; for WAV inputs, use _tmp suffix
        const isMp3 = inputName.toLowerCase().endsWith('.mp3');
        const tempName = isMp3
          ? inputName.replace(/\.mp3$/i, '.wav')
          : inputName.replace(/\.[^\.]+$/, '_tmp.wav');

        // 3. Build FFmpeg args for conversion to 44.1kHz mono, strip all metadata
        const args = ['-i', inputName, '-vn', '-ar', '44100', '-ac', '1', '-map_metadata', '-1'];
        if (audioHighPass) {
          args.push('-af', 'highpass=f=100,highpass=f=100,highpass=f=100,volume=5dB');
        }
        args.push(tempName);

        // 4. Run conversion
        await ffmpeg.exec(args);

        // 5. Read converted output
        const outData = await ffmpeg.readFile(tempName);

        // 6. Add to zip at desired path
        zip.file(zipPath, outData);

        // 7. Log conversion (unless suppressed)
        if (!suppressConversionLog) {
          const source = file._original || file.webkitRelativePath;
          const msg =
            '<span style="color:#99fff5; font-weight:bold">Audio converted:</span> ' +
            `<span style="color:#fff">${source}</span> ` +
            '<span style="color:#ff0">‚Üí</span> ' +
            `<span style="color:#9f6">${zipPath}</span>`;
          logFn(msg, "default");
        }

        // 8. Clean up MEMFS
        await ffmpeg.deleteFile(inputName);
        await ffmpeg.deleteFile(tempName);
      }
      window.normalizeAndZipAudio = normalizeAndZipAudio;

      // --- Main renaming + zipping logic ---
      renameBtn.addEventListener('click', async () => {
        // Allow scrolling during/after conversion
        document.body.style.overflow = "";
        document.body.style.height = "";
        document.body.style.paddingBottom = "30px"; // or whatever your footer's true height is
        // Reset working file list from the original input on each run
        files = Array.from(originalFiles);
        files.forEach(f => { f._original = f.webkitRelativePath; });

        if (multipleFontsCheckbox.checked) {
          // Group files by first subfolder (immediate children of top folder)
          const fontFolders = new Map();
          files.forEach(file => {
            const parts = file.webkitRelativePath.split('/');
            // Ignore files not in a subfolder
            if (parts.length > 1 && parts[1] && !file.name.startsWith('.')) {
              const fontFolder = parts[1];
              if (!fontFolders.has(fontFolder)) fontFolders.set(fontFolder, []);
              fontFolders.get(fontFolder).push(file);
            }
          });
          if (fontFolders.size === 0) {
            universalLog(logEl, "No subfolders found to process as fonts.", "error");
            return;
          }

          // === Multiple Fonts button processing ===
          // For each font folder, process and download a zip
          for (const [fontFolderName, fontFiles] of fontFolders.entries()) {
            // Set up conversionLogEntries cleanly for each font
            conversionLogEntries = [];
            clearLog();
            universalLog(logEl,`Renaming font: ${fontFolderName} (${sourceBoardEl.value} ‚Üí ${targetBoardEl.value})`, "info");
            if (renameHighPassCheckbox.checked) logHighPass(logEl, true);
            universalLog(logEl, "", "default");

            const ffmpeg = new FFmpeg({ log: true, corePath: './ffmpeg/ffmpeg-core.js' });
            await ffmpeg.load();
            const zip = new JSZip();
            const mainHpSuffix = renameHighPassCheckbox.checked ? '_HP' : '';
            const rootBase =
              (targetBoardEl.value.toUpperCase() === 'GOLDEN_HARVEST'
                ? `sound1 - ${fontFolderName}_${targetBoardEl.value}`
                : `${fontFolderName}_${targetBoardEl.value}`);
            const rootFolderName = `${rootBase}${mainHpSuffix}`;

            // Only process files for this font folder
            let fontFilesProcessed = [];
            for (const file of fontFiles) {
              fontFilesProcessed.push(file);
            }

            // Pre-convert audio files for this font (reuse your same processing)
            const processedFiles = [];
            for (const file of fontFilesProcessed) {
              const lower = file.name.toLowerCase();
              let needsConvert = false;
              if (lower.endsWith('.mp3') || lower.endsWith('.mp4')) {
                needsConvert = true;
              } else if (lower.endsWith('.wav')) {
                const arr = await file.arrayBuffer();
                const view = new DataView(arr);

                // Default offsets for standard WAV (RIFF) PCM
                let fmtChunkOffset = 12;
                let foundFmt = false;
                let sampleRate = 0;
                let bits = 0;

                // Find 'fmt ' chunk (handle non-standard chunk ordering)
                while (fmtChunkOffset + 8 < arr.byteLength) {
                  const chunkId = String.fromCharCode(
                    view.getUint8(fmtChunkOffset),
                    view.getUint8(fmtChunkOffset + 1),
                    view.getUint8(fmtChunkOffset + 2),
                    view.getUint8(fmtChunkOffset + 3)
                  );
                  const chunkSize = view.getUint32(fmtChunkOffset + 4, true);
                  if (chunkId === 'fmt ') {
                    foundFmt = true;
                    // PCM sample rate is at offset +12, bits per sample at +22
                    sampleRate = view.getUint32(fmtChunkOffset + 12, true);
                    bits = view.getUint16(fmtChunkOffset + 22, true);
                    break;
                  }
                  fmtChunkOffset += 8 + chunkSize;
                }
                if (!foundFmt) {
                  // fallback to standard positions (may be wrong, but better than nothing)
                  sampleRate = view.getUint32(24, true);
                  bits = view.getUint16(34, true);
                }

                // Debug output for diagnosis:
                console.log("[WAV CHECK]", file.name, "sampleRate:", sampleRate, "bits:", bits);

                // Treat 0 or obviously invalid values as "needs conversion"
                if (!sampleRate || sampleRate < 8000 || sampleRate > 192000) needsConvert = true;
                if (!bits || bits > 32) needsConvert = true;
                if (sampleRate !== 44100 || bits !== 16 || renameHighPassCheckbox.checked) needsConvert = true;
              }
              if (needsConvert) {
                const originalPath = file.webkitRelativePath;
                const tempName = file.name.replace(/\.[^\.]+$/, '_tmp.wav').replace(/\.mp3$/i, '.wav').replace(/\.mp4$/i, '.wav');
                await ffmpeg.writeFile(file.name, new Uint8Array(await file.arrayBuffer()));
                const args = ['-i', file.name, '-vn', '-ar', '44100', '-ac', '1', '-map_metadata', '-1'];
                if (renameHighPassCheckbox.checked) {
                  args.push('-af', 'highpass=f=100,highpass=f=100,highpass=f=100,volume=5dB');
                }
                args.push(tempName);
                await ffmpeg.exec(args);
                const outData = await ffmpeg.readFile(tempName);
                const newName = tempName.replace(/_tmp\.wav$/, '.wav');
                const newFile = new File([outData.buffer], newName, { type: 'audio/wav' });
                newFile._original = originalPath;
                newFile.webkitRelativePath = originalPath.replace(/\.[^\.]+$/, '.wav');
                processedFiles.push(newFile);
                await ffmpeg.deleteFile(file.name);
                await ffmpeg.deleteFile(tempName);
              } else {
                processedFiles.push(file);
              }
            }

            // Pre-process extras/tracks/non-wavs for this font
            let coreFiles = await handleExtrasAndTracks(processedFiles, zip, log, conversionLogEntries, rootFolderName);

            // Board-specific logic (same as before)
            const src = sourceBoardEl.value.toUpperCase();
            const tgt = targetBoardEl.value.toUpperCase();

            if (src === "PROFFIE" && tgt === "PROFFIE") {
              await fat32ProffieOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
              finalizeAndDownload(src, tgt, zip, rootFolderName, fontFolderName);
              continue;
            }
            if (tgt === "CFX") {
              await CFXOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
              finalizeAndDownload(src, tgt, zip, rootFolderName, fontFolderName);
              continue;
            }
            if (tgt === "VERSO") {
              await VERSOOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
              finalizeAndDownload(src, tgt, zip, rootFolderName, fontFolderName);
              continue;
            }
            if (tgt === "GOLDEN_HARVEST") {
              await GHOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
              finalizeAndDownload(src, tgt, zip, rootFolderName, fontFolderName);
              continue;
            }
            if (tgt === "XENO3") {
              await XENO3Organizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
              finalizeAndDownload(src, tgt, zip, rootFolderName, fontFolderName);
              continue;
            }
            if (tgt === "PROFFIE") {
              await fat32ProffieOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
              finalizeAndDownload(src, tgt, zip, rootFolderName, fontFolderName);
              continue;
            }
          }
          return; // Don't run the normal single-font flow
        }

        // === Single font/√ºber font logic (default) ===
        // (leave existing single-font logic untouched after this point)
        // Always create a new FFmpeg instance per run to reset memory
        const ffmpeg = new FFmpeg({ log: true, corePath: './ffmpeg/ffmpeg-core.js' });
        await ffmpeg.load();
        // Reset conversion log entries
        conversionLogEntries = [];
        clearLog();
        // Show header
        universalLog(logEl,`Renaming files: ${sourceBoardEl.value} ‚Üí ${targetBoardEl.value}...\n`, "info");
        // Log high-pass status at the top if enabled
        if (renameHighPassCheckbox.checked) logHighPass(logEl, true);
        universalLog(logEl, "", "default");

        // Create new zip
        const zip = new JSZip();
        // Determine root folder name for zip, with optional HP suffix
        const mainHpSuffix = renameHighPassCheckbox.checked ? '_HP' : '';
        const baseName = originalFiles[0].webkitRelativePath.split('/')[0];
        const rootBase =
          (targetBoardEl.value.toUpperCase() === 'GOLDEN_HARVEST'
            ? `sound1 - ${baseName}_${targetBoardEl.value}`
            : `${baseName}_${targetBoardEl.value}`);
        const rootFolderName = `${rootBase}${mainHpSuffix}`;

        // Pre-convert audio files (MP3/MP4 and non-44.1kHz/16-bit WAV) to proper WAV before renaming
        // === CHUNKED audio conversion for √ºber mode ===
        const processedFiles = [];
        const audioFiles = files.filter(file => {
          const lower = file.name.toLowerCase();
          return lower.endsWith('.wav') || lower.endsWith('.mp3') || lower.endsWith('.mp4');
        });
        const nonAudioFiles = files.filter(file => {
          const lower = file.name.toLowerCase();
          return !lower.endsWith('.wav') && !lower.endsWith('.mp3') && !lower.endsWith('.mp4');
        });

        // Add non-audio files directly, unchanged
        for (const file of nonAudioFiles) {
          processedFiles.push(file);
        }

        const chunkSize = 100;
        for (let i = 0; i < audioFiles.length; i += chunkSize) {
          const chunk = audioFiles.slice(i, i + chunkSize);
          const ffmpeg = new FFmpeg({ log: true, corePath: './ffmpeg/ffmpeg-core.js' });
          await ffmpeg.load();

          for (const file of chunk) {
            try {
<!--              console.log("About to process:", file.webkitRelativePath, file.name);-->
              const lower = file.name.toLowerCase();
              let needsConvert = false;
              if (lower.endsWith('.mp3') || lower.endsWith('.mp4')) {
                needsConvert = true;
              } else if (lower.endsWith('.wav')) {
                const arr = await file.arrayBuffer();
                const view = new DataView(arr);
                const sampleRate = view.getUint32(24, true);
                const bits = view.getUint16(34, true);
                // Convert if format is wrong or high-pass filtering is requested
                if (sampleRate !== 44100 || bits !== 16 || renameHighPassCheckbox.checked) needsConvert = true;
              }
              if (needsConvert) {
                const originalPath = file.webkitRelativePath;
                const tempName = file.name.replace(/\.[^\.]+$/, '_tmp.wav').replace(/\.mp3$/i, '.wav').replace(/\.mp4$/i, '.wav');
                await ffmpeg.writeFile(file.name, new Uint8Array(await file.arrayBuffer()));

                // FFmpeg args for normalization, optional high-pass, and strip metadata
                const args = ['-i', file.name, '-vn', '-ar', '44100', '-ac', '1', '-map_metadata', '-1'];
                if (renameHighPassCheckbox.checked) {
                  args.push('-af', 'highpass=f=100,highpass=f=100,highpass=f=100,volume=5dB');
                }
                args.push(tempName);
                await ffmpeg.exec(args);
                const outData = await ffmpeg.readFile(tempName);
                const newName = tempName.replace(/_tmp\.wav$/, '.wav');

                // --- PATCHED: Remove ALL leading baseName from path ---
                let rel = originalPath;
                // Defensive loop: strips every occurrence of baseName + "/" from the start
                const basePattern = new RegExp('^' + baseName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '/+');
                while (basePattern.test(rel)) {
                  rel = rel.replace(basePattern, '');
                }
                const normalizedRel = rel.replace(/\.[^\.]+$/, '.wav');
                // PATCH: Remove all occurrences of baseName from start of normalizedRel before assigning to webkitRelativePath
                let zipRel = normalizedRel;
                while (zipRel.startsWith(baseName + "/")) {
                  zipRel = zipRel.slice(baseName.length + 1);
                }
                // END PATCH

                console.log("CONVERTED", originalPath, "==>", zipRel); // optional debug

                const newFile = new File([outData.buffer], newName, { type: 'audio/wav' });
                newFile._original = originalPath;
                newFile.webkitRelativePath = zipRel;
                processedFiles.push(newFile);

                await ffmpeg.deleteFile(file.name);
                await ffmpeg.deleteFile(tempName);
              } else {
                processedFiles.push(file);
              }
            } catch (err) {
              // Enhanced error logging!
              let fileLabel = file.webkitRelativePath || file.name;
              let msg = `<span style="color:#ffb0a5">Error processing ${fileLabel}: ${err && err.message ? err.message : err}</span>`;
              universalLog(logEl, msg, "error");
              console.error("Error processing", fileLabel, err);
            }
          }
          // Allow ffmpeg instance to be garbage collected before next chunk
        }
        files = processedFiles;

        // Pre-process extras, tracks, and non-wavs
        let coreFiles = await handleExtrasAndTracks(files, zip, log, conversionLogEntries, rootFolderName);

        // Board-specific logic
        const src = sourceBoardEl.value.toUpperCase();
        const tgt = targetBoardEl.value.toUpperCase();

        if (src === "PROFFIE" && tgt === "PROFFIE") {
          await fat32ProffieOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
        if (tgt === "CFX") {
          await CFXOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
        if (tgt === "VERSO") {
          await VERSOOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
        if (tgt === "GOLDEN_HARVEST") {
          await GHOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
        if (tgt === "XENO3") {
          await XENO3Organizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
        if (tgt === "PROFFIE") {
          await fat32ProffieOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          finalizeAndDownload(src, tgt, zip, rootFolderName);
          return;
        }
      });



    // Audio‚ÄëOnly modal behavior
    const audioOnlyButton = document.getElementById('audioOnlyButton');
    const audioOnlyWindow = document.getElementById('audioOnlyWindow');
    const audioCloseButton = document.getElementById('audioCloseButton');

    audioOnlyButton.addEventListener('click', () => {
      // Hide main log when showing audio modal
      logEl.style.display = 'none';
      audioOnlyWindow.classList.add('visible');
    });
    audioCloseButton.addEventListener('click', () => {
      audioOnlyWindow.classList.remove('visible');
      // Restore main log when closing audio modal
      logEl.style.display = '';
    });

    // Define audio-only log helpers (after FFmpegWASM loaded)
    const audioLogEl = document.getElementById('audioLog');

    // Show "Ready to audio convert" on file selection
    const audioInput = document.getElementById('audioInput');
    audioInput.addEventListener('change', () => {
      // Clear previous messages and show ready info
      audioLogEl.innerHTML = '';
      const folderName = audioInput.files[0]?.webkitRelativePath.split('/')[0] || 'selected';
      universalLog(audioLogEl,`<span style="color:#99fff5; font-weight:bold">Ready to Convert Audio-Only - ${folderName}...</span>`);
      // Log high-pass readiness if checked
      const audioHighPassCheckbox = document.getElementById('audioHigh');
      if (audioHighPassCheckbox.checked) logHighPass(audioLogEl, true);
    });

    // Audio-only modal high-pass checkbox logging
    const audioHighPassCheckbox = document.getElementById('audioHigh');
    audioHighPassCheckbox.addEventListener('change', () => {
      removeHighPassNote();
        if (audioHighPassCheckbox.checked) logHighPass(audioLogEl, true);
    });

    // FFmpeg‚Äëwasm initialization and conversion logic
    document.getElementById('convertAudioButton').addEventListener('click', async () => {
      // Grab high-pass checkbox locally to avoid TDZ issues
      const audioHighPassCheckbox = document.getElementById('audioHigh');
      try {
        audioLogEl.innerHTML = "";
        // Re-add header line showing folder name
        const folderName = document.getElementById('audioInput').files[0]?.webkitRelativePath.split('/')[0] || 'selected';
        universalLog(audioLogEl,`<span style="color:#99fff5; font-weight:bold">Converting Audio-Only - ${folderName}...</span>`);
        // Log high-pass status visibly and for zipped log if enabled
        if (audioHighPassCheckbox.checked) {
          universalLog(audioLogEl, "High-Pass filtering enabled.", "info", "high-pass-enabled");
        }

        // Add blank line before any moved/converted file logs
        universalLog(audioLogEl, "", "default");
        // Patch: Set corePath to ffmpeg/ffmpeg-core.js so FFmpegWASM finds the WASM binary
        const ffmpeg = new FFmpeg({
          log: true,
          corePath: './ffmpeg/ffmpeg-core.js'
        });
        await ffmpeg.load();
        // Create the zip object immediately after ffmpeg.load()
        const zip = new JSZip();

        // Gather files, skipping hidden dotfiles (do not log dotfiles)
        const allFiles = Array.from(document.getElementById('audioInput').files)
          .filter(file => !file.name.startsWith('.'));
        // Support WAV and MP3 files
        const audioFiles = allFiles.filter(file => {
          const lower = file.name.toLowerCase();
          return lower.endsWith('.wav') || lower.endsWith('.mp3');
        });

        // Compute folder suffix and root folder for zip
        const audioHPSuffix = audioHighPassCheckbox.checked ? '_HP' : '';
        const baseFolder = document.getElementById('audioInput').files[0]?.webkitRelativePath.split('/')[0] || 'selected';
        const rootZipFolder = `${baseFolder}${audioHPSuffix}`;

        // Log and zip non-audio files (e.g., images, txt), using full relative path
        allFiles.forEach(file => {
          const lower = file.name.toLowerCase();
          if (!lower.endsWith('.wav') && !lower.endsWith('.mp3')) {
            // --- fix: remove all leading baseFolder(s) from rel ---
            let rel = file.webkitRelativePath;
            while (rel.startsWith(baseFolder + "/")) {
              rel = rel.slice(baseFolder.length + 1);
            }
            const zipPath = rel ? `${rootZipFolder}/${rel}` : `${rootZipFolder}/${file.name}`;
            universalLog(audioLogEl,
              '<span style="color:#99fff5">- Moved non-audio file:</span> ' +
              `<span style="color:#fff">${file.webkitRelativePath}</span> ` +
              '<span style="color:#ff0">‚Üí</span> ' +
              `<span style="color:#9f6">${zipPath}</span>`
            );
            zip.file(zipPath, file);
          }
        });
        if (!audioFiles.length) {
          universalLog(audioLogEl,'<span style="color:#99fff5">Audio-Only: No audio files selected</span>');
          return;
        }

        // Audio conversion logic: handle WAV and MP3 files (no chunking needed for audio-only)
        // Audio conversion logic: CHUNKED to avoid wasm memory errors!
        const chunkSize = 50;
        for (let i = 0; i < audioFiles.length; i += chunkSize) {
          const chunk = audioFiles.slice(i, i + chunkSize);
          const ffmpeg = new FFmpeg({
            log: true,
            corePath: './ffmpeg/ffmpeg-core.js'
          });
          await ffmpeg.load();

          for (const file of chunk) {
            try {
              let rel = file.webkitRelativePath;
              // Strip all leading baseFolder(s) from rel
              while (rel.startsWith(baseFolder + "/")) {
                rel = rel.slice(baseFolder.length + 1);
              }
              let zipPath = `${rootZipFolder}/${rel}`;
              // If MP3, always convert to WAV and update output path
              if (file.name.toLowerCase().endsWith('.mp3')) {
                zipPath = zipPath.replace(/\.mp3$/i, '.wav');
                await normalizeAndZipAudio({
                  file,
                  ffmpeg,
                  zip,
                  zipPath,
                  audioHighPass: audioHighPassCheckbox.checked,
                  logFn: (msg, type = "info") => universalLog(audioLogEl, msg, type),
                  suppressConversionLog: true
                });
                universalLog(audioLogEl,
                  '<span style="color:#99fff5; font-weight:bold">Audio converted:</span> ' +
                  `<span style="color:#fff">${rel}</span> ` +
                  '<span style="color:#ff0">‚Üí</span> ' +
                  `<span style="color:#9f6">${zipPath}</span>`
                );
                if (audioHighPassCheckbox.checked) {
                  universalLog(audioLogEl,
                    '<span style="color:#99fff5; font-weight:bold">Audio (high-pass):</span> ' +
                    `<span style="color:#fff">${rel.replace(/\.mp3$/i, '.wav')}</span> ‚Üí applied high-pass filter.`
                  );
                }
                continue;
              }
              // WAV Files: Inspect header for sample rate/bit depth
              const arrayBuffer = await file.arrayBuffer();
              const view = new DataView(arrayBuffer);

              // Default offsets for standard WAV (RIFF) PCM
              let fmtChunkOffset = 12;
              let foundFmt = false;
              let sampleRate = 0;
              let bitsPerSample = 0;

              // Find 'fmt ' chunk (handle non-standard chunk ordering)
              while (fmtChunkOffset + 8 < arrayBuffer.byteLength) {
                const chunkId = String.fromCharCode(
                  view.getUint8(fmtChunkOffset),
                  view.getUint8(fmtChunkOffset + 1),
                  view.getUint8(fmtChunkOffset + 2),
                  view.getUint8(fmtChunkOffset + 3)
                );
                const chunkSize = view.getUint32(fmtChunkOffset + 4, true);
                if (chunkId === 'fmt ') {
                  foundFmt = true;
                  sampleRate = view.getUint32(fmtChunkOffset + 12, true);
                  bitsPerSample = view.getUint16(fmtChunkOffset + 22, true);
                  break;
                }
                fmtChunkOffset += 8 + chunkSize;
              }
              if (!foundFmt) {
                // fallback to standard positions
                sampleRate = view.getUint32(24, true);
                bitsPerSample = view.getUint16(34, true);
              }

              // Debug output for diagnosis:
              console.log("[WAV CHECK]", file.name, "sampleRate:", sampleRate, "bits:", bitsPerSample);

              // Treat 0 or obviously invalid values as "needs conversion"
              if (!sampleRate || sampleRate < 8000 || sampleRate > 192000) {
                await normalizeAndZipAudio({
                  file,
                  ffmpeg,
                  zip,
                  zipPath,
                  audioHighPass: audioHighPassCheckbox.checked,
                  logFn: (msg, type = "info") => universalLog(audioLogEl, msg, type)
                });
                if (audioHighPassCheckbox.checked) {
                  universalLog(audioLogEl,
                    '<span style="color:#99fff5; font-weight:bold">Audio (high-pass):</span> ' +
                    `<span style="color:#fff">${rel}</span> ‚Üí applied high-pass filter.`
                  );
                }
                continue;
              }
              if (!bitsPerSample || bitsPerSample > 32) {
                await normalizeAndZipAudio({
                  file,
                  ffmpeg,
                  zip,
                  zipPath,
                  audioHighPass: audioHighPassCheckbox.checked,
                  logFn: (msg, type = "info") => universalLog(audioLogEl, msg, type)
                });
                if (audioHighPassCheckbox.checked) {
                  universalLog(audioLogEl,
                    '<span style="color:#99fff5; font-weight:bold">Audio (high-pass):</span> ' +
                    `<span style="color:#fff">${rel}</span> ‚Üí applied high-pass filter.`
                  );
                }
                continue;
              }
              // WAV already correct format, High-Pass OFF: just zip
              if (sampleRate === 44100 && bitsPerSample === 16 && !audioHighPassCheckbox.checked) {
                universalLog(audioLogEl,
                  '<span style="color:#99fff5; font-weight:bold">Audio:</span> ' +
                  `<span style="color:#fff">${rel}</span> is already good to go.`
                );
                zip.file(zipPath, file);
                continue;
              }
              // WAV is correct format, but High-Pass is ON
              if (sampleRate === 44100 && bitsPerSample === 16 && audioHighPassCheckbox.checked) {
                universalLog(audioLogEl,
                  '<span style="color:#99fff5; font-weight:bold">Audio (high-pass):</span> ' +
                  `<span style="color:#fff">${rel}</span> ‚Üí applied high-pass filter.`
                );
                await normalizeAndZipAudio({
                  file,
                  ffmpeg,
                  zip,
                  zipPath,
                  audioHighPass: audioHighPassCheckbox.checked,
                  logFn: (msg, type = "info") => universalLog(audioLogEl, msg, type),
                  suppressConversionLog: true
                });
                continue;
              }
              // WAV not correct format, or needs High-Pass
              await normalizeAndZipAudio({
                file,
                ffmpeg,
                zip,
                zipPath,
                audioHighPass: audioHighPassCheckbox.checked,
                logFn: (msg, type = "info") => universalLog(audioLogEl, msg, type)
              });
              if (audioHighPassCheckbox.checked) {
                universalLog(audioLogEl,
                  '<span style="color:#99fff5; font-weight:bold">Audio (high-pass):</span> ' +
                  `<span style="color:#fff">${rel}</span> ‚Üí applied high-pass filter.`
                );
              }
            } catch (fileErr) {
              let errorString;
              if (fileErr && typeof fileErr === "object") {
                errorString = fileErr.message || JSON.stringify(fileErr);
              } else {
                errorString = String(fileErr);
              }
              universalLog(audioLogEl,
                '<span style="color:#ffb0a5">Error processing ' +
                `<span style="color:#fff">${file.name}</span>: ${errorString}</span>`
              );
              console.error("Error processing", file.name, fileErr);
            }
          }
          // let this ffmpeg instance be GC'd
        }

        // Add to onscreen log:
        universalLog(audioLogEl, "", "default");
        universalLog(audioLogEl, "Audio-Only Conversion complete.", "info");
        universalLog(audioLogEl, buildFooterBanner(), "default");

        // Add to Audio-Only Conversion log by copying onscreen log entries:
        const header = buildLogHeader(
          'Audio-Only Conversion Log',
          '',
          '',
          '',
          audioHighPassCheckbox.checked
        );
        const rawLines = Array.from(audioLogEl.querySelectorAll('div')).map(div => div.textContent.trim());
        const body = '\n' + rawLines.join('\n') + '\n';
        zip.file(`${rootZipFolder}/_Audio_Conversion_Log.txt`, header + body);

      // Zip Converted files up
        const blob = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `Converted_Audio_${folderName}${audioHPSuffix}.zip`;
        document.body.appendChild(link);
        link.click();
        link.remove();
      } catch (e) {
        universalLog(audioLogEl,'Audio conversion failed: ' + e.message);
      }
    });

const popup = document.getElementById('popup');
const popupCloseButton = document.getElementById('popupCloseButton');
const dontShowAgainCheckbox = document.getElementById('dontShowAgain');
const versionChangelogButton = document.getElementById('versionChangelogButton');

document.addEventListener('DOMContentLoaded', function () {
    // If you have other UI init, leave those too!
    // Example: closeButton.click(); fileInputButton.classList.remove('available');
    // Only keep if relevant. Otherwise, can remove/comment those two lines.

    // Check localStorage to determine if the popup should be shown
    const dontShowAgainFlag = localStorage.getItem('dontShowChangelog');
    if (dontShowAgainFlag === 'true') {
        dontShowAgainCheckbox.checked = true;
    } else {
        popup.classList.add('show');
    }

    popupCloseButton.addEventListener('click', function () {
        popup.classList.remove('show');
        localStorage.setItem('dontShowChangelog', dontShowAgainCheckbox.checked ? 'true' : 'false');
    });

    dontShowAgainCheckbox.addEventListener('change', function () {
        localStorage.setItem('dontShowChangelog', this.checked ? 'true' : 'false');
    });

    versionChangelogButton.addEventListener('click', function () {
        dontShowAgainCheckbox.checked = localStorage.getItem('dontShowChangelog') === 'true';
        popup.classList.add('show');
    });
});

  </script>
</body>
</html>

<!--
100% working!?
-->

