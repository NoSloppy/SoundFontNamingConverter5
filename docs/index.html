<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/png" href="favicon.png">
  <title>SoundFontNamingConverter (Browser-based)</title>
  <link rel="stylesheet" href="cleaned_styles.css">
</head>
<body>
  <div id="popup" class="popup">
    <button id="popupCloseButton" class="close-button">&#10006;</button>
        <label class="dont-show-label">
            <input type="checkbox" id="dontShowAgain">
            <span>Don't show this on page load</span>
        </label>
    <div id="popupContent">
        <h2>Version Changelog</h2>

        <p>[5.1.0]<br>
          <strong>Added / Changed</strong><br>
          &bull; <strong>Custom dropdown selectors and file chooser:</strong><br>
          &nbsp;&nbsp;Now custom-styled elements to be consistent with the rest of the interface.<br>
          &nbsp;&nbsp;No more default browser menu buttons (I'm looking at YOU, Safari!)<br>
          &bull; <strong>Improved layout for workflow:</strong><br>
          &nbsp;&nbsp;Top controls always remain visible, and log messages now display in a scrollable window.<br>
          &nbsp;&nbsp;All fonts shown back-to-back Multiple Font conversions, but still each has it's own log in zipped folders.<br>
          &bull; <strong>UI alignment and style polish:</strong><br>
          &nbsp;&nbsp;Everything lines up better and button highlights are now consistent. Cool glow, huh?<br>
          <br>
          <strong>Fixed</strong><br>
          &bull; <strong>Conversion logs for Multiple Fonts:</strong><br>
          &nbsp;&nbsp;Fixed an issue where running Multiple Fonts did not generate Conversion logs inside the downloaded ZIP.<br>
          &bull; <strong>Logging bugs squashed:</strong><br>
          &nbsp;&nbsp;All audio conversion and renaming logs are now clear, consistent, and mirrored in the console.<br>

        </p>
        <p>[5.0.0]<br>
          <strong>Version 5: Browser-Based Lightning Speed!</strong><br>
          &bull; <strong>Brand new browser-based converter:</strong> No files are uploaded! Everything is processed instantly in your browser with NO lag, NO waiting on slow servers, and no limits to how many users can run it at once.<br>
          <br>
          &bull; <strong>NEW UI!</strong> Streamlined interface makes getting around and getting your results faster than ever. Output logs are bigger, color-coded, and much easier to read, and downloads are automatically triggered.<br>
          <br>
          &bull; <strong>All your favorite features are here:</strong><br>
          &nbsp;&nbsp;&ndash; Board-specific renaming: Handles Proffie, CFX, Golden Harvest, Verso, and Xeno3, including special rules for CFX mixed numbered/unnumbered files, Xeno parenthesis, auto-inclusion of Verso blaster sound, Golden Harvest and Proffie settings files, and more.<br>
          &nbsp;&nbsp;&ndash; <strong>Multiple fonts at once:</strong> Process tons of subfolders in one go, and it‚Äôs FAST!<br>
          &nbsp;&nbsp;&ndash; <strong>Proffie font optimization:</strong> Instantly organizes fonts for best FAT32 SD card performance, automatically applied any time Proffieboard is the target. Includes correctly organizing file structure, wrangling loose files from root, etc...<br>
          &nbsp;&nbsp;&ndash; <strong>Auto-Audio Conversion:</strong> Renaming automatically converts mis-formatted wavs, converts mp3's, and strips metadata from audio files. Sweet!<br>
          &nbsp;&nbsp;&ndash; <strong>Audio-only conversion:</strong> Converts WAV and MP3 files to 44.1kHz, 16-bit mono (no renaming, just pure conversion for soundboard compatibility).<br>
          &nbsp;&nbsp;&ndash; <strong>High-pass filtering option:</strong> Make sure your fonts sound clean on small saber speakers.<br>
          &nbsp;&nbsp;&ndash; <strong>Conversion logs provided with every conversion:</strong> Keep a clear record of everything that happened, included in your download.<br>
          <br>
          &bull; <strong>Bonus:</strong> Quick links to the best saber sites, right in the footer.<br>
          <br>
          &bull; <strong>Please consider the Buy Me A Coffee link below if this tool helped you out. This was a lot of work üòâ</strong>
          <div style="text-align:center; margin-top:0.5em;">
            <strong>Thank you! ‚òï</strong>
          </div>
        </p>

        <p>[4.3.4]<br>
        <strong>Fixed</strong><br>
        &bull; Fixed mp3 conversion bug.<br>
        &bull; Fixed high-pass bug.<br>
        </p>

        <p>[4.3.3]<br>
        <strong>Fixed</strong><br>
        &bull; Fixed logging for Audio Conversion.<br>
        </p>

        <p>[4.3.2]<br>
        <strong>Fixed</strong><br>
        &bull; Fixed Sample Rate conversion error.<br>
        </p>

        <p>[4.3.1]<br>
        <strong>Added</strong><br>
        &bull; Version Changelog popup.<br>
        &bull; BC Style Editor link in Other Sites section.<br>
        </p>

        <p>[4.3.0]<br>
        <strong>Added</strong><br>
        &bull; Dedicated Golden Harvest naming instead of suggesting to just use CFX naming.<br>
        &bull; Add Golden Harvest settings.txt to the font folder in the process.<br>
        &bull; Timestamp to Conversion_log.txt.<br>
        <strong>Changed</strong><br>
        &bull; Changed GH3 to just Golden Harvest, as there‚Äôs now a GH4 as well that uses the same convention.<br>
        &bull; Changed board dropdown menus to mixed instead of all CAPS.<br>
        &bull; Changed ‚ÄúConvert‚Äù to ‚ÄúRename‚Äù throughout, except Convert Audio, because that is actual conversion.<br>
        &bull; Verso: Changed any extra font files to fontALT instead of boot files.<br>
        <strong>Fixed</strong><br>
        &bull; Fixed status text that wasn‚Äôt showing the source font folder name.<br>
        &bull; Fixed Semantic Versioning of this project!<br>
        </p>

        <p>[4.2.1]<br>
        <strong>Fixed</strong><br>
        &bull; Fixed optimization checkbox hover tips.<br>
        </p>

        <p>[4.2.0]<br>
        <strong>Added</strong><br>
        &bull; Optional Enable High Pass filter to both renaming and audio convert only routines.<br>
        &bull; Automatically apply 40 sample fade-in and fade-out to front and end of WAVs to prevent clicking.<br>
        &bull; Automatically scroll to bottom to reveal Download button when ready.<br>
        </p>

        <p>[4.1.1]<br>
        <strong>Added</strong><br>
        &bull; Metadata tags are automatically removed (Artist, Title, Genre etc...)<br>
        </p>

        <p>[4.1.0]<br>
        <strong>Added</strong><br>
        &bull; Support for mp4 video files!<br>
        &nbsp;&nbsp; Audio will be grabbed from video files and converted to ideal .wav format as well.<br>
        &bull; Specific Golden Harvest naming fixes.<br>
        &bull; CFX results now properly do not number the first blaster.wav file.<br>
        &bull; Tracks, extras, bonus etc‚Ä¶ files no longer changed to all lowercase.<br>
        &bull; Verso 2.0 support - also add blast1.wav for blaster firing sound.<br>

        <p>[4.0.0]<br>
        <strong>Added</strong><br>
        &bull; Support for .mp3 files. They will be converted to ideal .wav format.<br>
        &bull; Stand-alone audio converter without renaming or restructuring anything with the "Convert Audio Only" button up top.<br>
        &nbsp;&nbsp; Download starts automatically when finished.<br>
        &bull; "Multiple Fonts" checkbox allows for selecting a folder of font folders to be processed.<br>
        &nbsp;&nbsp; This applies automatically to Audio Only conversions.<br>
        &bull; Proffie: Support for Alt, sub-sub, and "tr" sounds.<br>
        <strong>Changed</strong><br>
        &bull; File chooser interface customized to reflect when available / unavailable, with chosen folder details shown.<br>
        <strong>Fixed</strong><br>
        &bull; Better handling of tracks, "extra" or "bonus" material.<br>
        &bull; Improved logging.<br>
        </p>

        <p>[3.1.0]<br>
        <strong>Added</strong><br>
        &bull; Audio is automatically checked and converted to proper specs if needed. (44.1kHz, 16bit, monaural .wav file)<br>
        &bull; Add multiple download slots to allow for concurrent users.<br>
        &bull; Remove uploaded and zipped files after 3 minutes instead of at next conversion.<br>
        &bull; Processed files are sorted in expected order to retain same file numbers on output.<br>
        &bull; Downloaded font folder is labeled as font_board (so like Dooku_PROFFIE) to avoid mixing your fonts up.<br>
        &bull; GUI improvements:<br>
        &nbsp;&nbsp; Live, scrollable log view of conversion process.<br>
        &nbsp;&nbsp; Log output is written to a Conversion Log and is included with the converted font.<br>
        &nbsp;&nbsp; Separate upload and progress bars just because.<br>
        <strong>Changed</strong><br>
        &bull; Proffie Optimizer button hidden when not applicable.<br>
        &bull; GUI improvements:<br>
        &nbsp;&nbsp; Convert button shows availability with red or green. Larger too.<br>
        &nbsp;&nbsp; Larger, colorful download button is removed when download expires.<br>
        &nbsp;&nbsp; Dynamic Download button text.<br>
        &nbsp;&nbsp; More informative progress bar text including font name, source and target board, upload and download status, and error messages.<br>
        &nbsp;&nbsp; Tool tip changes depending on Optimize for Proffie checkbox enabled or not.<br>
        </p>

        <p>[3.0.0]<br>
        <strong>Added</strong><br>
        &bull; Proffie: Adds missing default config.ini and smoothsw.ini files.<br>
        </p>
    </div>
  </div>

  <input type="hidden" name="sourceBoard" id="sourceBoard" value="CFX">
  <input type="hidden" name="targetBoard" id="targetBoard" value="CFX">
  <div class="main-content">
    <h1>SoundFontNamingConverter MVP <span style="color:#fff;font-size:0.62em;"> Version 5.1.0 </span></h1>
    <div class="top-flex-row">
      <!-- LEFT SIDE -->
      <div class="left-controls">
        <div class="step-label">1. Choose a source and target format:</div>
        <div class="dropdown-row">
          <div class="custom-dropdown" id="sourceBoardSelect" tabindex="0" style="margin-right:1em;">
            <button type="button" class="custom-dropdown-trigger">CFX</button>
            <ul class="custom-dropdown-options">
              <li class="custom-dropdown-option selected" data-value="PROFFIE">Proffieboard</li>
              <li class="custom-dropdown-option" data-value="CFX">CFX</li>
              <li class="custom-dropdown-option" data-value="VERSO">Verso</li>
              <li class="custom-dropdown-option" data-value="XENO3">Xeno3</li>
              <li class="custom-dropdown-option" data-value="GOLDEN_HARVEST">Golden Harvest</li>
            </ul>
          </div>
          <div class="custom-dropdown" id="targetBoardSelect" tabindex="0">
            <button type="button" class="custom-dropdown-trigger">CFX</button>
            <ul class="custom-dropdown-options">
              <li class="custom-dropdown-option selected" data-value="PROFFIE">Proffieboard</li>
              <li class="custom-dropdown-option" data-value="CFX">CFX</li>
              <li class="custom-dropdown-option" data-value="VERSO">Verso</li>
              <li class="custom-dropdown-option" data-value="XENO3">Xeno3</li>
              <li class="custom-dropdown-option" data-value="GOLDEN_HARVEST">Golden Harvest</li>
            </ul>
          </div>
        </div>
        <div class="step-label" style="margin-top: 1em;">2. Select a folder of sound font files:</div>
        <div class="files-chooser-row">
          <input type="file" id="folderInput" webkitdirectory directory multiple>
          <label class="file-chooser-label" for="folderInput">
            <span id="fileChooserLabelText">Choose Folder...</span>
          </label>
        </div>
      </div>
      <!-- RIGHT SIDE -->
        <div class="right-controls">
          <div class="checkbox-row">
            <input type="checkbox" id="multipleFontsCheckbox" name="multipleFontsCheckbox" class="multiple-fonts-checkbox">
            <label for="multipleFontsCheckbox" class="multiple-fonts-label"
              title="Process each subfolder as a separate font">Multiple Fonts</label>
          </div>
          <div class="checkbox-row">
            <input type="checkbox" id="mainHighPass" class="rename-highpass-checkbox">
            <label for="mainHighPass" class="rename-highpass-label">Enable High-Pass Filter</label>
          </div>
          <div class="button-row">
            <button type="button" id="renameBtn" class="action-btn" disabled>Rename & Download Zip</button>
            <button type="button" id="audioOnlyButton" class="action-btn audio-only-button">Convert Audio Only</button>
          </div>
        </div>
      </div>
    <div id="log"></div>
  </div>
  <div class="footer-container">
    <span class="footer-title">NoSloppy - 2025</span>
    <button id="versionChangelogButton" class="footer-button" title="View the version changelog" type="button">Version Changelog</button>
    <a href="https://www.buymeacoffee.com/BrianConner" title="Brian Conner supports the saber community. Support him back.">
      <img class="donate-button" src="donateButton.jpg" alt="Buy me a coffee"></a>
    <span class="footer-links">
      <span class="other-sites">Other sites:</span>
      <a href="https://nosloppy.github.io/ProffieOS-StyleEditor-1/style_editor_BC_V6.html" target="_blank" title="BC Style Editor"><img src="https://nosloppy.github.io/ProffieOS-StyleEditor-1/SE_Favicon.png" alt="BC Style Editor logo"></a>
      <a href="https://crucible.hubbe.net/" target="_blank" title="The Crucible"><img src="https://crucible.hubbe.net/uploads/default/optimized/1X/2237f551ca8f4f69ac478df5c64aee1c951c33f5_2_180x180.png" alt="Crucible logo"></a>
      <a href="https://pod.hubbe.net/" target="_blank" title="ProffieOS Documentation site"><img src="https://pod.hubbe.net/images/favicon.png" alt="Pod logo"></a>
      <a href="https://fredrik.hubbe.net/lightsaber/" target="_blank" title="Profezzorn's Proffieboard site"><img src="https://fredrik.hubbe.net/favicon.ico" alt="Lightsaber logo"></a>
      <a href="https://www.fett263.com/" target="_blank" title="Fett263's Style Library"><img src="https://www.fett263.com/favicon.ico" alt="Fett263 logo"></a>
      <a href="https://www.facebook.com/groups/opensourcesabers/" target="_blank" title="Open Source Group"><img src="https://www.facebook.com/favicon.ico" alt="Facebook logo"></a>
      <a href="https://crystalfocus.net/" target="_blank" title="crystalfocus.net"><img src="https://crystalfocus.net/images/logo.ico" alt="crystalfocus.net logo"></a>
      <a href="https://sabertec.net/" target="_blank" title="sabertec.net"><img src="https://sabertec.net/wp-content/uploads/2016/12/cropped-Logo-Sabertec-Bildmarke-V2-Hintergrund-32x32.png" alt="sabertec.net logo"></a>
      <a href="https://darkwolfsabers.com/" target="_blank" title="darkwolfsabers.com"><img src="https://img1.wsimg.com/isteam/ip/494b9647-5ed3-4359-92d3-188572d6d1f1/favicon/95b2b868-5641-4853-8c6d-057e8ebf1d55.jpeg/:/rs=w:16,h:16,m" alt="darkwolfsabers.com logo"></a>
    </span>
  </div>

  <!-- Load local UMD FFmpeg wrapper -->
  <script src="./ffmpeg/ffmpeg.js"></script>
  <script>
    // UMD exposes FFmpegWASM global
    if (!window.FFmpegWASM || typeof FFmpegWASM.FFmpeg !== 'function') {
      console.error('Local UMD FFmpegWASM failed to load; FFmpeg class is undefined.');
    } else {
      console.log('Local UMD FFmpegWASM loaded:', FFmpegWASM);
    }
    const { FFmpeg } = FFmpegWASM;
  </script>
  <div id="audioOnlyWindow" class="audio-only-window">
    <button type="button" id="audioCloseButton" class="close-button">&#10006;</button>
    <h2 class="centered-header">Convert to 44.1‚ÄØkHz 16‚Äëbit mono WAV</h2>
    <div style="margin:1em 0;">
      <input type="file" id="audioInput" webkitdirectory multiple>
    </div>
    <div style="margin-bottom:1em;">
      <label><input type="checkbox" id="audioHigh"> Enable High‚ÄëPass Filter</label>
    </div>
    <div id="audioLog"></div>
    <button type="button" id="convertAudioButton" class="convert-audio-button">Convert Audio & Download Zip</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    console.log("HELLO FROM TOP OF SCRIPT");
    // Mapping CSV URLs for every board combo
    const CSV_URLS = {
      "CFX_TO_PROFFIE":             "CSV/CFX_TO_PROFFIE.csv",
      "GOLDEN_HARVEST_TO_PROFFIE":   "CSV/GOLDEN_HARVEST_TO_PROFFIE.csv",
      "PROFFIE_TO_CFX":             "CSV/PROFFIE_TO_CFX.csv",
      "PROFFIE_TO_GOLDEN_HARVEST":  "CSV/PROFFIE_TO_GOLDEN_HARVEST.csv",
      "PROFFIE_TO_VERSO":           "CSV/PROFFIE_TO_VERSO.csv",
      "PROFFIE_TO_XENO3":           "CSV/PROFFIE_TO_XENO3.csv",
      "VERSO_TO_PROFFIE":           "CSV/VERSO_TO_PROFFIE.csv",
      "XENO3_TO_PROFFIE":           "CSV/XENO3_TO_PROFFIE.csv"
    };

    // === Footer Banner Constant ===
    const FOOTER_BANNER_TEXT = '------------------ | **** MTFBWY **** | ------------------';

    // === Unified Logger Utilities ===
    const fileLogLines = [];
    // Audio‚ÄëOnly plain-text log buffer
    const audioFileLogLines = [];
    function stripHtml(html) {
      const tmp = document.createElement('div');
      tmp.innerHTML = html;
      return tmp.textContent;
    }
    function logMessage(msg, type = "default") {
      // Queue for on-screen (dot-matrix) rendering
      logQueue.push({ el: logEl, msg, type, className: "", afterFirst: false });
      if (!logProcessing) processLogQueue();
      // Also record plain-text for file
      fileLogLines.push(stripHtml(msg));
    }
    // Alias existing universalLog calls to the new logger:
    function universalLog(el, msg, type = "default", className = "", afterFirst = false) {
      // Mirror plain-text logs to the dev console for main log (rename/download), not just audio-only
      if (el === logEl) {
        const txt = stripHtml(msg)
          .replace(/ +/g, ' ')
          .replace(/\n+/g, '\n')
          .replace(/ +‚Üí +/g, ' ‚Üí ');
        if (txt && txt.trim()) console.log(txt);
        fileLogLines.push(txt);
      }
      // For audio-only, keep as before
      if (el && el.id === 'audioLog') {
        audioFileLogLines.push(stripHtml(msg));
      }
      // On-screen log queueing as before
      logQueue.push({ el, msg, type, className, afterFirst });
      if (!logProcessing) processLogQueue();
    }
    // === DOM ===
    const logEl = document.getElementById('log');
    const folderInput = document.getElementById('folderInput');
    const sourceBoardEl = document.getElementById('sourceBoard');
    const targetBoardEl = document.getElementById('targetBoard');
    const renameBtn = document.getElementById('renameBtn');
    const renameHighPassCheckbox = document.getElementById('mainHighPass');
    const multipleFontsCheckbox = document.getElementById('multipleFontsCheckbox');
    const fileLabel = document.querySelector('.file-chooser-label');
    
    document.addEventListener('DOMContentLoaded', function() {
      checkReady();
    });
    
    // Check if ready for renaming
    function checkReady() {
      const sourceVal = sourceBoardEl.value;
      const targetVal = targetBoardEl.value;
      // valid if boards differ, or special Proffie‚ÜíProffie case
      const comboValid =
        sourceVal !== targetVal ||
        (sourceVal === 'PROFFIE' && targetVal === 'PROFFIE');
    
      // keep a local var so our console.log can reference it
      const chooserEnabled = comboValid;
      setFolderChooserEnabled(chooserEnabled);
      const fileLabelText = document.getElementById("fileChooserLabelText");
      if (comboValid) {
        fileLabelText.textContent = "Choose Folder‚Ä¶";
      } else {
        fileLabelText.textContent = "Choose a valid board combo first‚Ä¶";
      }

      // Enable rename only if files selected + combo valid + mapping ready
      const renameEnabled = files.length > 0 && comboValid && mappingReady;
      renameBtn.disabled = !renameEnabled;

      console.log('chooserEnabled:', chooserEnabled, 'renameEnabled:', renameEnabled, 'files.length:', files.length);
    }

    // --- Custom Dropdown Logic ---
    function setupCustomSelect(containerId, inputId, onChange) {
      const select = document.getElementById(containerId);
      const trigger = select.querySelector('.custom-dropdown-trigger');
      const options = select.querySelector('.custom-dropdown-options');
      const opts = options.querySelectorAll('.custom-dropdown-option');
      const hiddenInput = document.getElementById(inputId);

      function updateOptionsList(selectedValue) {
        // Only show options not currently selected
        options.innerHTML = "";
        Array.from(opts).forEach(opt => {
          if (opt.dataset.value !== selectedValue) {
            const newOpt = opt.cloneNode(true);
            newOpt.classList.remove('selected');
            options.appendChild(newOpt);
            newOpt.addEventListener('click', function() {
              trigger.textContent = this.textContent;
              hiddenInput.value = this.dataset.value;
              select.classList.remove('open');
              updateOptionsList(this.dataset.value);
              if (onChange) onChange(this.dataset.value);
            });
          }
        });
      }
      // On first load, hide selected
      updateOptionsList(hiddenInput.value);

      trigger.addEventListener('click', function(e) {
        select.classList.toggle('open');
      });

      // Keyboard nav (basic)
      select.addEventListener('keydown', function(e) {
        if (e.key === " " || e.key === "Enter") {
          select.classList.toggle('open');
          e.preventDefault();
        }
        if (e.key === "Escape") {
          select.classList.remove('open');
          trigger.blur();
        }
        if (e.key === "ArrowDown" || e.key === "ArrowUp") {
          const selIdx = Array.from(opts).findIndex(o => o.classList.contains('selected'));
          let next = selIdx + (e.key === "ArrowDown" ? 1 : -1);
          if (next < 0) next = opts.length - 1;
          if (next >= opts.length) next = 0;
          opts.forEach(o => o.classList.remove('selected'));
          opts[next].classList.add('selected');
          trigger.textContent = opts[next].textContent;
          hiddenInput.value = opts[next].dataset.value;
          if (onChange) onChange(opts[next].dataset.value);
          e.preventDefault();
        }
      });

      // Click outside to close
      document.addEventListener('click', function(e) {
        if (!select.contains(e.target)) select.classList.remove('open');
      });
    }

    // Call for each dropdown, and re-use your mapping reload function
    setupCustomSelect('sourceBoardSelect', 'sourceBoard', autoSelectAndLoadMapping);
    setupCustomSelect('targetBoardSelect', 'targetBoard', autoSelectAndLoadMapping);

    // Custom File Chooser
    document.getElementById('folderInput').addEventListener('change', function(e) {
      const label = document.getElementById('fileLabelText');
      if (this.files.length > 0) {
        // Show number of files/folders
        label.textContent = this.files.length + ' file(s) selected';
      } else {
        label.textContent = 'Choose Folder...';
      }
    });

    // Overlay function for zipping
    function showZippingOverlay(show=true) {
      const overlay = document.getElementById('zippingOverlay');
      if (show) {
        overlay.classList.add('active');
      } else {
        overlay.classList.remove('active');
      }
    }

    // Helper: Wait for log to finish, show overlay, finalize download, hide overlay
    async function finalizeAndDownloadWithOverlay(src, tgt, zip, rootFolderName, fontFolderName = "") {
      function waitForLogDone() {
        return new Promise(resolve => {
          function check() {
            if (!logProcessing) resolve();
            else setTimeout(check, 15);
          }
          check();
        });
      }
      await waitForLogDone();
      showZippingOverlay(true);
      finalizeAndDownload(src, tgt, zip, rootFolderName, fontFolderName);
      // finalizeAndDownload will hide overlay after download
    }

    // === State ===
    let files = [];
    let originalFiles = [];
    let mapping = {};
    let mappingReady = false;
    let conversionLogEntries = [];

    // Track recognition: Load known_tracks.txt from the same directory as index.html
    let knownTracksSet = new Set();

    async function loadKnownTracks() {
      try {
        const resp = await fetch('known_tracks.txt');
        if (!resp.ok) throw new Error("Failed to fetch");
        const txt = await resp.text();
        knownTracksSet = new Set(txt.split(/\r?\n/).map(l => l.trim().toLowerCase()).filter(Boolean));
        console.log("Loaded known tracks:", knownTracksSet);
      } catch (err) {
        console.log("Could not load known_tracks.txt:", err);
        knownTracksSet = new Set();
      }
    }
    loadKnownTracks();

    // Logging
    let slowLogDelay = 2;    // ms per line, tweak as you like
    let logQueue = [];
    let logProcessing = false;


    function addLogEntry(el, msg, type = "default", className = "", afterFirst = false) {
      const colors = {
        info: "#99fff5",
        error: "#ffb0a5",
        success: "#9f6",
        default: "#e2e2e2"
      };
      const safeType = (type || "default").toLowerCase();
      const color = colors[safeType] || colors.default;

      const entry = document.createElement('div');
      entry.innerHTML = `<span style="color:${color}">${msg}</span>`;
      if (className) entry.classList.add(className);

      if (afterFirst && el.children.length > 1) {
        el.insertBefore(entry, el.children[1]);
      } else {
        el.appendChild(entry);
        entry.scrollIntoView({ behavior: "auto", block: "end" });
      }

      if (msg === "") {
        const br = document.createElement('br');
        if (className) br.classList.add(className);
        if (afterFirst && el.children.length > 2) {
          el.insertBefore(br, el.children[2]);
        } else {
          el.appendChild(br);
        }
      }
    }

    // Helper: log queue processor (for dot-matrix mode)
    function processLogQueue() {
      if (logQueue.length === 0) {
        logProcessing = false;
        return;
      }
      logProcessing = true;
      const { el, msg, type, className, afterFirst } = logQueue.shift();
      addLogEntry(el, msg, type, className, afterFirst);
      setTimeout(processLogQueue, slowLogDelay);
    }

    // === Log header/footer helpers ===
    function buildLogHeader(modeLabel, src, tgt, baseName) {
      let hdr =
        '------------------------------------------------\n' +
        'Renamed with SoundFontNamingConverter V5\n' +
        'Brian Conner a.k.a NoSloppy\n' +
        modeLabel + '\n' +
        new Date().toLocaleString() + '\n';
      hdr += '------------------------------------------------\n';
      return hdr;
    }

    // Unified banner helpers for logs and onscreen
    function buildFooterBanner() {
      return `<span style="color:#ffe066;font-weight:bold;">${FOOTER_BANNER_TEXT}</span>`;
    }

    // === Consolidated Logging Helpers ===

    // Format the header message string
    function formatHeaderMsg(baseName, src, tgt) {
      return `Renaming font: "${baseName}" from ${src} ‚Üí ${tgt}.`;
    }

    // Helper: Logs the per-font header both onscreen and for log file, returns log lines
    function logFontHeader(fontFolderName, src, tgt, highPassEnabled) {
      const headerLines = [];
      const headerMsg = formatHeaderMsg(fontFolderName, src, tgt);
      universalLog(logEl, headerMsg, "info");
      headerLines.push(headerMsg);
      if (highPassEnabled) {
        logHighPass(logEl, true);
        headerLines.push("High-Pass filtering enabled.");
      }
      universalLog(logEl, "", "default");
      headerLines.push(""); // Blank line after header
      return headerLines;
    }


    function logHighPass(el, afterFirst = false) {
      // Remove any existing High-Pass log lines
      document.querySelectorAll('.high-pass-enabled').forEach(el => {
        const next = el.nextSibling;
        el.remove();
        if (next && next.nodeName === 'BR') next.remove();
      });
      universalLog(el, "High-Pass filtering enabled.", "info", "high-pass-enabled", afterFirst);
    }

    function removeHighPassNote() {
      document.querySelectorAll('.high-pass-enabled').forEach(el => {
        const next = el.nextSibling;
        el.remove();
        if (next && next.nodeName === 'BR') next.remove();
      });
    }

    function clearLog() {
      logEl.innerHTML = "";
      document.body.style.overflow = "clip";
      document.body.style.paddingBottom = "0";
    }

    // Parse CSV (mapping) text into an object
    function parseCSV(csv) {
      const lines = csv.split(/\r?\n/);
      const map = {};
      for (const line of lines) {
        if (!line.trim()) continue;
        const [orig, renamed] = line.split(',').map(x => x.trim());
        if (orig && renamed) map[orig.toLowerCase()] = renamed;
      }
      return map;
    }

    function buildReverseMap(forwardMap) {
      const reverse = {};
      for (const [k, v] of Object.entries(forwardMap)) {
        if (!reverse[v]) reverse[v] = k;
      }
      return reverse;
    }

    // === Utility: single call to add to zip, conversionLogEntries, and log in one go ===
    function addZipEntry(zip, file, zipPath, label = 'Renamed') {
      zip.file(zipPath, file);
      // Determine source path: prefer original snapshot, fallback to webkitRelativePath
      const srcPath = file._original || file.webkitRelativePath;
      // Push to conversion log (normalize arrow)
      conversionLogEntries.push(`${label}: ${srcPath} -> ${zipPath}`);
      // Colorized on-screen log: white source, yellow arrow, green target
     universalLog(logEl,`Renamed: <span style="color:#fff">${srcPath}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipPath}</span>`);
    }

    // === Utility: unified track detection ===
    function isTrackFile(file) {
      const name = file.name.toLowerCase();
      const parts = file.webkitRelativePath.toLowerCase().split('/');
      return knownTracksSet.has(name)
          || parts.includes('tracks')
          || /(track|theme|song|music)/.test(name);
    }

    // Helper: Load direct or reverse mapping as object
    async function getMappingObj(csvKey, reverse = false) {
      const csv = await (await fetch(CSV_URLS[csvKey])).text();
      const obj = parseCSV(csv);
      return reverse ? buildReverseMap(obj) : obj;
    }

    // Combine reverse-of-first + direct second mapping in one call
    async function loadBidirectionalMapping(revKey, directKey) {
      const forward = await getMappingObj(revKey);
      const reverse = buildReverseMap(forward);
      const direct  = await getMappingObj(directKey);
      return { ...reverse, ...direct };
    }


    // Helper to prompt user to select files for a renaming set
    function promptSelectFiles(src, tgt) {
      mappingReady = true;
     universalLog(logEl,`${src} ‚Üí ${tgt} renaming set, please choose files above.`, "info");
      // Sync high-pass message
      document.querySelectorAll('.high-pass-enabled').forEach(el => {
        const next = el.nextSibling;
        el.remove();
        if (next && next.nodeName === 'BR') next.remove();
      });
      if (renameHighPassCheckbox.checked) {
        logHighPass(logEl, true);
        logEl.scrollTop = 0; // Scroll to top so message is visible
      }
      folderInput.disabled = false;
    }

    // Helper: finalize zip, build log, trigger download, and UI reset
    function finalizeAndDownload(src, tgt, zip, rootFolderName, fontFolderName = "") {
      // Write plain-text conversion log from unified logger
      const header = buildLogHeader('Font Renaming Log', src, tgt);
      const body   = fileLogLines.join('\n') + '\n';
      const baseName = fontFolderName || rootFolderName.split('_')[0];
      // Build the done-line by reusing the header format and swapping the trailing period
      const doneLine = formatHeaderMsg(baseName, src, tgt).replace(/\.$/, ' Done.');
      const footerText = stripHtml(buildFooterBanner());
      zip.file(
        `${rootFolderName}/_Conversion_Log.txt`,
        header + '\n' + body + '\n' + doneLine + '\n' + footerText + '\n'
      );
      // On-screen footer: blank line, done line, footer banner, and spacing
      universalLog(logEl, "", "default");
      universalLog(logEl, doneLine, "info");
      universalLog(logEl, buildFooterBanner(), "default");
      universalLog(logEl, "", "default");
      universalLog(logEl, "", "default");
      // Zip Renamed files up
      zip.generateAsync({ type: 'blob' }).then(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const mainHpSuffix = renameHighPassCheckbox.checked ? '_HP' : '';
        let fontSuffix = fontFolderName ? ("_" + fontFolderName) : "";
        a.download = `Renamed_${src}_to_${tgt}${fontSuffix}${mainHpSuffix}.zip`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => {
          universalLog(logEl, "<br><br>");
          renameBtn.disabled = false;
          showZippingOverlay(false);
        }, 50);
      });
    }

    /**
     * Pre-processes files to handle non-wav, track, and extras files uniformly.
     * Moves handled files into the zip and returns only the core wav files for board-specific logic.
     */
    async function handleExtrasAndTracks(files, zip, log, conversionLogEntries, rootFolderName) {
      const remaining = [];
      const root = rootFolderName;
      for (const file of files) {
        if (file.name.startsWith('.')) continue;
        const nameLower = file.name.toLowerCase();
        // Use the preserved original path for logging when available
        const rel = file._original || file.webkitRelativePath;
        // 1) Non-wav files: copy any non-wav (e.g., .ini, .bmp) to root
        if (!nameLower.endsWith('.wav')) {
          const zipPath = `${root}/${file.name}`;
          zip.file(zipPath, file);
         universalLog(logEl,`<span style="color:#99fff5">- Moved non-wav file:</span> <span style="color:#fff">${rel}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipPath}</span>`);
          conversionLogEntries.push(`- Moved non-wav file ${rel} ‚Üí ${zipPath}`);
          continue;
        }
        // 2) Track files: unified detection
        if (isTrackFile(file)) {
          const zipPath = `${root}/tracks/${file.name}`;
         universalLog(logEl,'(‚åê‚ñ†_‚ñ†) This looks like a track file.', 'info');
          zip.file(zipPath, file);
         universalLog(logEl,`<span style="color:#99fff5">- Moved track file:</span> <span style="color:#fff">${rel}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipPath}</span>`);
          conversionLogEntries.push(`- Moved track file: ${rel} ‚Üí ${zipPath}`);
          continue;
        }
        // 3) Extras/bonus folders
        const parts = rel.split('/');
        const idx = parts.map(p => p.toLowerCase()).findIndex(p => /(extra|xtra|bonus)/.test(p));
        if (idx !== -1) {
          const sub = parts.slice(idx + 1).join('/');
          const zipPath = `${root}/extras${sub ? '/' + sub : ''}`;
          zip.file(zipPath, file);
         universalLog(logEl,`<span style="color:#99fff5">- Moved extra or bonus file:</span> <span style="color:#fff">${rel}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipPath}</span>`);
          conversionLogEntries.push(`- Moved extra or bonus file: ${rel} ‚Üí ${zipPath}`);
          continue;
        }
        // Otherwise, leave for board-specific processing
        remaining.push(file);
      }
      return remaining;
    }

    // Load CSV mapping as soon as both dropdowns are selected
    async function autoSelectAndLoadMapping() {
      // Reset UI
      mappingReady = false;
      renameBtn.textContent = 'Rename & Download Zip';
      renameBtn.disabled = true;
      folderInput.disabled = true;
      clearLog();
      showMultipleFontsExplainer();
      const src = sourceBoardEl.value;
      const tgt = targetBoardEl.value;

      // Case 1: identical boards
      if (src === tgt) {
        if (src === "PROFFIE") {
         universalLog(logEl,"Proffieboard to Proffieboard organizes and renames a ProffieOS sound font for best FAT32 performance.", "info");
          mapping = {};
          mappingReady = true;
          setFolderChooserEnabled(true);
          document.getElementById("fileChooserLabelText").textContent = "Choose Folder‚Ä¶";
          folderInput.disabled = false;
          checkReady();
          // Add high-pass message if enabled
          if (renameHighPassCheckbox.checked) logHighPass(logEl, true);
        } else {
         universalLog(logEl,`Renaming from ${src} ‚Üí ${tgt} is unnecessary.`, "info");
        setFolderChooserEnabled(false);
        }
        return;
      }

      // Case 2: chained conversion (neither PROFFIE)
      if (src !== "PROFFIE" && tgt !== "PROFFIE") {
        try {
          const srcToPro = await loadBidirectionalMapping(`PROFFIE_TO_${src}`, `${src}_TO_PROFFIE`);
          const proToTgt = await getMappingObj(`PROFFIE_TO_${tgt}`);
          mapping = key => {
            const lower = key.toLowerCase();
            const mid = srcToPro[lower] || lower;
            return proToTgt[mid.toLowerCase()] || mid;
          };
          promptSelectFiles(src, tgt);
          renameHighPassCheckbox.disabled = false;
          checkReady();
        } catch (e) {
         universalLog(logEl,`Failed to set up ${src}‚Üí${tgt} chained mapping: ${e}`, "error");
        }
        return;
      }

      // Case 3: direct conversion (one end PROFFIE)
      try {
        let mapObj;
        // mapping from other‚ÜíPROFFIE
        if (tgt === "PROFFIE") {
          mapObj = await loadBidirectionalMapping(`PROFFIE_TO_${src}`, `${src}_TO_PROFFIE`);
        }
        // mapping from PROFFIE‚Üíother
        else if (src === "PROFFIE") {
          mapObj = await getMappingObj(`PROFFIE_TO_${tgt}`);
        }
        // fallback direct if CSV exists
        else {
          const key = `${src}_TO_${tgt}`;
          mapObj = CSV_URLS[key] ? await getMappingObj(key) : {};
        }
        mapping = mapObj;
        promptSelectFiles(src, tgt);
        renameHighPassCheckbox.disabled = false;
        checkReady();
      } catch (e) {
       universalLog(logEl,`Failed to load ${src}‚Üí${tgt} mapping: ${e}`, "error");
      }
    }


    function setFolderChooserEnabled(enabled) {
      const fileLabelText = document.getElementById('fileChooserLabelText');
      const label = document.querySelector('.file-chooser-label');
      folderInput.disabled = !enabled;
      if (enabled) {
        label.classList.remove('disabled');
        fileLabelText.textContent = 'Choose Folder...';
      } else {
        label.classList.add('disabled');
        fileLabelText.textContent = 'Choose a valid board combo first...';
      }
    }
      // Change the label text accordingly:
      // if (chooserEnabled) {
        // fileLabelText.textContent = 'Choose Folder...';
      // } else {
        // fileLabelText.textContent = 'Choose a valid board combo first...';
      // }


    // Dropdown change handlers
    // (No longer add 'change' listeners for hidden <input>; handled by custom dropdown logic now)
    autoSelectAndLoadMapping(); // On page load

    // Folder/file picker handler
    folderInput.addEventListener('change', (e) => {
      files = Array.from(e.target.files);
      originalFiles = Array.from(e.target.files);
      clearLog();
      showMultipleFontsExplainer();
      if (files.length) {
       universalLog(logEl,`Selected ${files.length} files from folder: <b>${files[0].webkitRelativePath.split('/')[0]}</b>`);
        if (mappingReady)universalLog(logEl,`${sourceBoardEl.value} ‚Üí ${targetBoardEl.value} renaming ready.`, "info");
        if (renameHighPassCheckbox.checked) {
         universalLog(logEl,'High-Pass filtering enabled.', 'info');
        }
      }
      checkReady();
      renameBtn.textContent = 'Rename & Download Zip';
    });


    multipleFontsCheckbox.addEventListener('change', function() {
      // Remove any old explanation lines
      document.querySelectorAll('.multiple-fonts-explainer').forEach(el => el.remove());
      if (this.checked) {
        // Insert clear explanation to the log
        universalLog(
          logEl,
          // "Multiple Fonts: Each immediate subfolder of the selected folder will be processed as an individual sound font.",
          `<span style="color:#ffe066;font-weight:bold">Multiple Fonts <span style="color:red;">ON</span>: Each immediate subfolder of the selected folder will be processed as an individual sound font.<br>
          If a folder contains multiple font folders and this is <span style="color:red;font-weight:bold">OFF</span>, all fonts within will be merged into one <span style="color:red;font-weight:bold">√ºber font</span>.</span>`,
          "default",
          "multiple-fonts-explainer",
          true  // insert after first line
        );
        logEl.scrollTop = 0;
      }
    });

    function showMultipleFontsExplainer() {
      // Only show if checked, and only if not already present
      if (multipleFontsCheckbox.checked &&
          !logEl.querySelector('.multiple-fonts-explainer')) {
        universalLog(
          logEl,
          `<span style="color:#ffe066;font-weight:bold">Multiple Fonts <span style="color:red;">ON</span>: Each immediate subfolder of the selected folder will be processed as an individual sound font.<br>
          If a folder contains multiple font folders and this is <span style="color:red;font-weight:bold">OFF</span>, all fonts within will be merged into one <span style="color:red;font-weight:bold">√ºber font</span>.</span>`,
          "default",
          "multiple-fonts-explainer",
          true
        );
        logEl.scrollTop = 0;
      }
    }

    // Rename High-Pass checkbox change logging (add/remove message as needed)
    renameHighPassCheckbox.addEventListener('change', () => {
      removeHighPassNote();
      if (renameHighPassCheckbox.checked) logHighPass(logEl, true);
    });

   async function fat32ProffieOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      // === Proffie altXXX folders support ===
      // collect any files under alt000, alt001, etc.
      const altFiles = files.filter(f => {
        const parts = f.webkitRelativePath.split('/');
        return /^alt\d{3}$/i.test(parts[1]);
      });
      if (altFiles.length) {
        // group by alt directory and by clean base name
        const altGroups = {};
        altFiles.forEach(f => {
          const parts = f.webkitRelativePath.split('/');
          const altDir = parts[1];
          const cleanName = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
          altGroups[altDir] = altGroups[altDir] || {};
          altGroups[altDir][cleanName] = altGroups[altDir][cleanName] || [];
          altGroups[altDir][cleanName].push(f);
        });
        const altDirs = Object.keys(altGroups).sort();
        // determine maximum count per base across all alt dirs
        const baseCounts = {};
        altDirs.forEach(dir => {
          Object.keys(altGroups[dir]).forEach(base => {
            baseCounts[base] = Math.max(baseCounts[base]||0, altGroups[dir][base].length);
          });
        });
        // fill missing entries by copying from any alt directory that has them
        altDirs.forEach(dir => {
          Object.entries(baseCounts).forEach(([base, count]) => {
            const arr = altGroups[dir][base] || [];
            for (let i = arr.length; i < count; i++) {
              // find first alt folder that has the file at this index
              let fileToCopy = null;
              for (const srcDir of altDirs) {
                const srcArr = altGroups[srcDir][base] || [];
                if (srcArr[i]) {
                  fileToCopy = srcArr[i];
                  break;
                }
              }
              if (fileToCopy) {
                arr.push(fileToCopy);
              }
            }
            altGroups[dir][base] = arr;
          });
        });
      // altBases: bases to process from alt groups
      const altBases = Object.keys(baseCounts);

      // incorporate stray root-level WAVs matching alt bases: distribute into each alt folder
      const strayRoot = files.filter(f => {
        const parts = f.webkitRelativePath.split('/');
        // skip files inside any altXXX folder
        if (!parts[1] || /^alt\d{3}$/i.test(parts[1])) return false;
        const clean = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        return altBases.includes(clean);
      });
      // add each stray file to every alt group
      strayRoot.forEach(f => {
        const clean = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        altDirs.forEach(dir => {
          altGroups[dir][clean].push(f);
        });
      });

      // remove altXXX files and stray root-level WAVs from main list
      files = files.filter(f => {
        const parts = f.webkitRelativePath.split('/');
        const isAltDir = /^alt\d{3}$/i.test(parts[1]);
        const clean = f.name.toLowerCase().replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        return !isAltDir && !altBases.includes(clean);
      });
      // --- handle numeric-only files: copy as-is before grouping ---
      const remainingAfterNumeric = [];
      for (const file of files) {
        if (/^\d+\.wav$/i.test(file.name)) {
          const parts = file.webkitRelativePath.split('/');
          const parent = parts[1] || '';
          const zipPath = parent
            ? `${rootFolderName}/${parent}/${file.name}`
            : `${rootFolderName}/${file.name}`;
          addZipEntry(zip, file, zipPath, 'Moved numeric file');
        } else {
          remainingAfterNumeric.push(file);
        }
      }
      files = remainingAfterNumeric;
        // now zip each alt group into its folder, numbering in sequence
        const applyMap = name => {
          const key = name.toLowerCase();
          const mapped = typeof mapping === 'function' ? mapping(key) : (mapping[key] || key);
          return mapped.replace(/\.wav$/, '');
        };
        altDirs.forEach(dir => {
          Object.entries(altGroups[dir]).forEach(([base, arr]) => {
            arr.forEach((f, idx) => {
              const mappedBase = applyMap(base);
              let outName;
              if (arr.length === 1) {
                // single per alt: no numeric suffix
                outName = `${mappedBase}.wav`;
              } else {
                // multiple: pad to two digits
                const suffix = String(idx+1).padStart(2, '0');
                outName = `${mappedBase}${suffix}.wav`;
              }
              const zipPath = `${rootFolderName}/${dir}/${outName}`;
              zip.file(zipPath, f);
              conversionLogEntries.push(`${f.webkitRelativePath} -> ${zipPath}`);
             universalLog(logEl,`Renamed: <span style="color:#fff">${f.webkitRelativePath}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipPath}</span>`);
            });
          });
        });
      }
      // If doing a Proffie‚ÜíProffie identity conversion, bypass all CSV mappings
      const isIdentityConversion = sourceBoardEl.value === 'PROFFIE' && targetBoardEl.value === 'PROFFIE';
      const applyMapping = name => {
        if (isIdentityConversion) return name;
        return typeof mapping === 'function' ? mapping(name) : (mapping[name] || name);
      };
      // Gather .wav files by base name, skip extras/bonus/track/music/etc folders for core handling
      const wavsByBase = {};
      const originals = {};
      // 1. Collect core wav files for FAT32 grouping
      for (const file of files) {
        if (file.name.startsWith('.') || !file.name.toLowerCase().endsWith('.wav')) continue;
        const nameLower = file.name.toLowerCase();
        const relParts = file.webkitRelativePath.split('/');
        let baseNameForGroup;
        if (/^\d+\.wav$/i.test(file.name) && relParts.length > 1) {
          baseNameForGroup = relParts[1].toLowerCase() + '.wav';
        } else {
          baseNameForGroup = nameLower.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        }
        const mapped = applyMapping(baseNameForGroup);
        const base = mapped.replace(/\.wav$/, '');
        wavsByBase[base] = wavsByBase[base] || [];
        wavsByBase[base].push(file);
        originals[file.name] = file.webkitRelativePath;
      }

      // 2. Handle all wavs in sorted order (for consistent numbering)
      for (const base of Object.keys(wavsByBase)) {
        let filesForBase = wavsByBase[base];
        filesForBase.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

        if (filesForBase.length === 1) {
          // Single file: strip Xeno (n) or trailing digits, map to Proffie, put in root
          let file = filesForBase[0];
          let cleanName = file.name.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav').toLowerCase();
          let mappedName = applyMapping(cleanName);
          let zipPath = `${rootFolderName}/${mappedName}`;
          addZipEntry(zip, file, zipPath);
        } else {
          // Multiples: put in subfolder, Proffie digits, mapped base name
          let file0 = filesForBase[0];
          let cleanName0 = file0.name.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav').toLowerCase();
          let mappedName0 = applyMapping(cleanName0);
          let mappedBase = mappedName0.replace(/\.wav$/, '');
          let subdir = `${rootFolderName}/${mappedBase}`;
          for (let i = 0; i < filesForBase.length; ++i) {
            let file = filesForBase[i];
            let num = i + 1;
            let useDoubleDigits = mappedBase.length <= 6;
            let useSingleDigit = mappedBase.length === 7 || mappedBase.length === 8;
            if (mappedBase === "tr") { useDoubleDigits = true; useSingleDigit = false; }
            let fileNum =
              mappedBase === "tr"
                ? String(num - 1).padStart(2, "0")
                : useDoubleDigits
                ? String(num).padStart(2, "0")
                : String(num);
            let newName = mappedBase + fileNum + ".wav";
            let zipPath = `${subdir}/${newName}`;
            addZipEntry(zip, file, zipPath);
          }
        }
      }
    }

    // --- CFX Organizer ---
    function CFXOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      const fileNameCounter = {};
      for (const file of files) {
        if (!file.name.toLowerCase().endsWith('.wav') || file.name.startsWith('.')) continue;
        // Numeric-only files: sequence by parent folder name
        if (/^\d+\.wav$/i.test(file.name)) {
          const parts = file.webkitRelativePath.split('/');
          const parent = parts.length > 1 ? parts[1] : '';
          const count = fileNameCounter[parent] || 1;
          const outName = `${parent}${count}.wav`;
          addZipEntry(zip, file, `${rootFolderName}/${outName}`);
          fileNameCounter[parent] = count + 1;
          continue;
        }
        // Map Proffie filenames to CFX names using the mapping object
        const origLower = file.name.toLowerCase();
        // Strip numeric suffixes for grouping (e.g. "boot01.wav" ‚Üí "boot.wav")
        const keyForMapping = origLower.replace(/(\d+)\.wav$/i, '.wav');
        // Apply mapping on stripped key, fallback to stripped key
        const mappedName = (typeof mapping === "function")
          ? mapping(keyForMapping)
          : (mapping[keyForMapping] || keyForMapping);
        // Derive baseKey (without extension) for duplicate counting
        const baseKey = mappedName.replace(/\.wav$/i, '');
        let counter = fileNameCounter[baseKey] || 1;
        let outName;

        switch (baseKey) {
          case "poweroff":
            if (counter === 1) {
              // First poweroff and also create pwroff2
              addZipEntry(zip, file, `${rootFolderName}/poweroff.wav`);
                            // Remove addZipEntry for pwroff2.wav, and instead log as dashMsgCreate and use zip.file directly
              const dashMsgCreate = "- Also create pwroff2.wav";
              universalLog(logEl, dashMsgCreate, "info");
              conversionLogEntries.push(dashMsgCreate);
              zip.file(`${rootFolderName}/pwroff2.wav`, file);
              // On-screen rename log matching addZipEntry style:
              const srcPathCreate = file._original || file.webkitRelativePath;
              universalLog(logEl, `Created: <span style="color:#fff">${srcPathCreate}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${rootFolderName}/pwroff2.wav</span>`);
              conversionLogEntries.push(`Created: ${srcPathCreate} -> ${rootFolderName}/pwroff2.wav`);
            } else if (counter === 2) {
              // Updated pwroff2 replacement
              const dashMsgUpdate = "- Updated pwroff2.wav";
              universalLog(logEl, dashMsgUpdate, "info");
              conversionLogEntries.push(dashMsgUpdate);
              zip.file(`${rootFolderName}/pwroff2.wav`, file);
              const srcPathUpdate = file._original || file.webkitRelativePath;
              universalLog(logEl, `Renamed: <span style="color:#fff">${srcPathUpdate}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${rootFolderName}/pwroff2.wav</span>`);
              conversionLogEntries.push(`Renamed: ${srcPathUpdate} -> ${rootFolderName}/pwroff2.wav`);
            } else {
              const outName = `poweroff${counter - 1}.wav`;
              addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            }
            fileNameCounter[baseKey] = counter + 1;
            break;

          case "font":
            if (counter === 1) {
              outName = "font.wav";
            } else {
             universalLog(logEl,"- CFX only uses one font file, so any additional become boots.", 'info');
              conversionLogEntries.push("- CFX only uses one font file, so any additional become boots.");
              const bootCount = fileNameCounter["boot"] || 1;
              outName = `boot${bootCount === 1 ? "" : bootCount}.wav`;
              fileNameCounter["boot"] = bootCount + 1;
            }
            addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            fileNameCounter[baseKey] = counter + 1;
            break;

          case "boot":
          case "poweron":
          case "lockup":
          case "blaster":
          case "drag":
          case "force":
          case "color":
            outName = `${baseKey}${counter === 1 ? "" : counter}.wav`;
            addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            fileNameCounter[baseKey] = counter + 1;
            break;

          default:
            outName = `${baseKey}${counter}.wav`;
            addZipEntry(zip, file, `${rootFolderName}/${outName}`);
            fileNameCounter[baseKey] = counter + 1;
            break;
        }
      }
      // Summary footnotes for CFX rules
      const pwroffCount = fileLogLines.filter(line => /pwroff2\.wav/.test(line)).length;
      if (pwroffCount >= 1) {
        universalLog(logEl, '-- CFX requires a "pwroff2" file for retractions when blade is moving.', 'info');
        universalLog(logEl, '-- So if only a single RETRACTION sound is received, it is made into both "poweroff" and "pwroff2" to fulfill the requirement.', 'info');
      }
      if (pwroffCount >= 2) {
        universalLog(logEl, '-- If a second RETRACTION sound comes through, then it is used for "pwroff2" instead, replacing the first instance.', 'info');
        universalLog(logEl, '-- Any additional RETRACTION sounds are then made as continued sequential "poweroff"s', 'info');
      }
    }

    // --- VERSO Organizer ---
    async function VERSOOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      // Pre-group all WAVs by base name (strip numeric suffixes)
      const filesByBase = {};
      for (const file of files) {
        if (!file.name.toLowerCase().endsWith('.wav') || file.name.startsWith('.')) continue;
        const key = file.name.toLowerCase().replace(/(\d+)\.wav$/i, '.wav');
        const mapped = (typeof mapping === "function")
          ? mapping(key)
          : (mapping[key] || key);
        const base = mapped.replace(/\.wav$/i, '');
        if (!filesByBase[base]) filesByBase[base] = [];
        filesByBase[base].push(file);
      }

      // Process each group
      for (const base of Object.keys(filesByBase).sort()) {
        const group = filesByBase[base];
        group.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
        // Special handling for font: first -> font.wav, rest -> fontALT1.wav, fontALT2.wav...
        if (base === 'font') {
          for (let i = 0; i < group.length; i++) {
            const file = group[i];
            const outName = i === 0
              ? 'font.wav'
              : `fontALT${i}.wav`;
            const zipPath = `${rootFolderName}/${outName}`;
            addZipEntry(zip, file, zipPath);
          }
        } else if (group.length === 1) {
          // Single file: base1.wav (always numbered)
          const file = group[0];
          const outName = `${base}1.wav`;
          const zipPath = `${rootFolderName}/${outName}`;
          addZipEntry(zip, file, zipPath);
        } else {
          // Multiple files: name1.wav, name2.wav, ...
          for (let i = 0; i < group.length; i++) {
            const file = group[i];
            const outName = `${base}${i + 1}.wav`;
            const zipPath = `${rootFolderName}/${outName}`;
            addZipEntry(zip, file, zipPath);
          }
        }
      }

      // Add mandatory Verso blast sound
      try {
        const resp = await fetch('Verso_Blast/blast1.wav');
        if (resp.ok) {
          const blob = await resp.blob();
          const blastZip = `${rootFolderName}/blast1.wav`;
          zip.file(blastZip, blob);
          // Verso-specific explanatory log
         universalLog(logEl,"-- Verso uses a 'blaster firing' sound before the 'deflection' sound, so it's been added for you.", "info");
          conversionLogEntries.push("-- Verso uses a 'blaster firing' sound before the 'deflection' sound, so it's been added for you.");
          // Add descriptive log for Verso blast requirement
          const versoMsg = "-- Added ";
         universalLog(logEl,`${versoMsg} ‚Üí ${blastZip}`, "info");
          conversionLogEntries.push(`${versoMsg} -> ${blastZip}`);
        }
      } catch (err) {
       universalLog(logEl,"Failed to add Verso blast sound: " + err, "error");
      }
    }

    // ---GOLDEN HARVEST Organizer ---
    async function GHOrganizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      const fileNameCounter = {};
      for (const file of files) {
        if (!file.name.toLowerCase().endsWith('.wav') || file.name.startsWith('.')) continue;
        const key = file.name.toLowerCase().replace(/(\d+)\.wav$/i, '.wav');
        const mapped = (typeof mapping === "function")
          ? mapping(key)
          : (mapping[key] || key);
        const base = mapped.replace(/\.wav$/i, '');
        let outName;
        if (base === 'font') {
          const cnt = (fileNameCounter[base] || 1);
          outName = cnt === 1 ? 'font.wav' : `fontALT${cnt-1}.wav`;
          fileNameCounter[base] = cnt + 1;
        } else {
          const cnt = (fileNameCounter[base] || 0) + 1;
          fileNameCounter[base] = cnt;
          outName = `${base}${cnt}.wav`;
        }
        const zipPath = `${rootFolderName}/${outName}`;
        addZipEntry(zip, file, zipPath);
      }
      // add settings.txt
      const resp = await fetch('GOLDEN_HARVEST_settings/settings.txt');
      if (resp.ok) {
        const blob = await resp.blob();
        const path = `${rootFolderName}/settings.txt`;
        zip.file(path, blob);
       universalLog(logEl,`-- Golden Harvest settings.txt added ‚Üí ${path}`, "info");
        conversionLogEntries.push(`- Golden Harvest settings.txt added -> ${path}`);
      }
    }

    // --- XENO3 Organizer ---
    function XENO3Organizer(files, mapping, rootFolderName, zip, log, conversionLogEntries) {
      const fileNameCounter = {};
      for (const file of files) {
        // skip hidden and non-wav files
        if (file.name.startsWith('.') || !file.name.toLowerCase().endsWith('.wav')) continue;
        // strip any numeric suffix or parenthesized number for mapping
        const nameLower = file.name.toLowerCase();
        const cleanName = nameLower.replace(/(?:\s*\(\d+\)|\d+)\.wav$/i, '.wav');
        // apply mapping to cleaned name
        let mappedWav;
        if (typeof mapping === 'function') {
          mappedWav = mapping(cleanName);
        } else {
          mappedWav = mapping[cleanName] || cleanName;
        }
        // strip extension for base
        const base = mappedWav.replace(/\.wav$/i, '');
        // increment counter for Xeno3 numbering
        const count = (fileNameCounter[base] || 0) + 1;
        fileNameCounter[base] = count;
        // build output name and path
        const outName = `${base} (${count}).wav`;
        const zipPath = `${rootFolderName}/${outName}`;
        addZipEntry(zip, file, zipPath);
      }
    }

      // === Audio normalization helper ===
      /**
       * Normalize a WAV or MP3 file to 44.1kHz, 16-bit mono with optional high-pass,
       * add result into zip at the same path, and log via callback.
       */
      async function normalizeAndZipAudio({ file, ffmpeg, zip, zipPath, audioHighPass, logFn, suppressConversionLog = false }) {
        const safeLog = logFn || ((msg, type = "info") => universalLog(audioLogEl, msg, type));

        // 1. Read and write original into MEMFS
        const arrayBuffer = await file.arrayBuffer();
        const inputName = file.name;
        await ffmpeg.writeFile(inputName, new Uint8Array(arrayBuffer));

        // 2. Determine temp output name
        //    For MP3 inputs, convert directly to .wav; for WAV inputs, use _tmp suffix
        const isMp3 = inputName.toLowerCase().endsWith('.mp3');
        const tempName = isMp3
          ? inputName.replace(/\.mp3$/i, '.wav')
          : inputName.replace(/\.[^\.]+$/, '_tmp.wav');

        // 3. Build FFmpeg args for conversion to 44.1kHz mono, strip all metadata
        const args = ['-i', inputName, '-vn', '-ar', '44100', '-ac', '1', '-map_metadata', '-1'];
        if (audioHighPass) {
          args.push('-af', 'highpass=f=100,highpass=f=100,highpass=f=100,volume=5dB');
        }
        args.push(tempName);

        // 4. Run conversion
        await ffmpeg.exec(args);

        // 5. Read converted output
        const outData = await ffmpeg.readFile(tempName);

        // 6. Add to zip at desired path
        zip.file(zipPath, outData);

        // 7. Log conversion (unless suppressed)
        if (!suppressConversionLog) {
          const source = file._original || file.webkitRelativePath;
          const msg =
            '<span style="color:#99fff5; font-weight:bold">Audio converted:</span> ' +
            `<span style="color:#fff">${source}</span> ` +
            '<span style="color:#ff0">‚Üí</span> ' +
            `<span style="color:#9f6">${zipPath}</span>`;
          logFn(msg, "default");
        }

        // 8. Clean up MEMFS
        await ffmpeg.deleteFile(inputName);
        await ffmpeg.deleteFile(tempName);
      }
      window.normalizeAndZipAudio = normalizeAndZipAudio;

      // === Shared: Normalize and return all audio files as 44.1kHz/16-bit mono WAV, optionally high-pass, using ffmpeg ===
      async function processAudioFiles({ files, ffmpeg, highPass, logFn }) {
        const processed = [];
        for (const file of files) {
          let needsConvert = false;
          const lower = file.name.toLowerCase();
          if (lower.endsWith('.mp3') || lower.endsWith('.mp4')) {
            needsConvert = true;
          } else if (lower.endsWith('.wav')) {
            const arr = await file.arrayBuffer();
            const view = new DataView(arr);
            let fmtChunkOffset = 12;
            let foundFmt = false;
            let sampleRate = 0;
            let bits = 0;
            while (fmtChunkOffset + 8 < arr.byteLength) {
              const chunkId = String.fromCharCode(
                view.getUint8(fmtChunkOffset),
                view.getUint8(fmtChunkOffset + 1),
                view.getUint8(fmtChunkOffset + 2),
                view.getUint8(fmtChunkOffset + 3)
              );
              const chunkSize = view.getUint32(fmtChunkOffset + 4, true);
              if (chunkId === 'fmt ') {
                foundFmt = true;
                sampleRate = view.getUint32(fmtChunkOffset + 12, true);
                bits = view.getUint16(fmtChunkOffset + 22, true);
                break;
              }
              fmtChunkOffset += 8 + chunkSize;
            }
            if (!foundFmt) {
              sampleRate = view.getUint32(24, true);
              bits = view.getUint16(34, true);
            }
            if (!sampleRate || sampleRate < 8000 || sampleRate > 192000) needsConvert = true;
            if (!bits || bits > 32) needsConvert = true;
            if (sampleRate !== 44100 || bits !== 16 || highPass) needsConvert = true;
          }
          if (needsConvert) {
            const originalPath = file._original || file.webkitRelativePath;
            const tempName = file.name.replace(/\.[^\.]+$/, '_tmp.wav').replace(/\.mp3$/i, '.wav').replace(/\.mp4$/i, '.wav');
            try {
              await ffmpeg.writeFile(file.name, new Uint8Array(await file.arrayBuffer()));
              const args = ['-i', file.name, '-vn', '-ar', '44100', '-ac', '1', '-map_metadata', '-1'];
              if (highPass) {
                args.push('-af', 'highpass=f=100,highpass=f=100,highpass=f=100,volume=5dB');
              }
              args.push(tempName);
              await ffmpeg.exec(args);
              const outData = await ffmpeg.readFile(tempName);
              if (!outData || !outData.length) {
                console.error('[FFmpeg] Output data is empty after conversion:', tempName);
              }
              const newName = tempName.replace(/_tmp\.wav$/, '.wav');
              let rel = originalPath;
              if (rel.includes("/")) {
                rel = rel.split('/').slice(1).join('/');
              }
              const zipRel = rel.replace(/\.[^\.]+$/, '.wav');
              const newFile = new File([outData.buffer], newName, { type: 'audio/wav' });
              newFile._original = originalPath;
              newFile.webkitRelativePath = zipRel;
              processed.push(newFile);
              await ffmpeg.deleteFile(file.name);
              await ffmpeg.deleteFile(tempName);
              if (logFn) {
                logFn(`<span style="color:#fff">Audio converted:</span> <span style="color:#fff">${originalPath}</span> <span style="color:#ff0">‚Üí</span> <span style="color:#9f6">${zipRel}</span>`);
              }
            } catch (err) {
              console.error('[FFmpeg ERROR] During conversion of', file.name, err);
              if (logFn) logFn(`<span style="color:#ffb0a5">Audio conversion failed for:</span> <span style="color:#fff">${originalPath}</span> - ${err.message}`);
            }
          } else {
            if (logFn && lower.endsWith('.wav') && !highPass) {
              let rel = file._original || file.webkitRelativePath;
              if (rel.includes("/")) {
                rel = rel.split('/').slice(1).join('/');
              }
              logFn(`<span style="color:#fff">Audio:</span> <span style="color:#fff">${rel}</span> is already good to go.`);
            }
            processed.push(file);
          }
        }
        return processed;
      }

      // --- Main renaming + zipping logic ---
      renameBtn.addEventListener('click', async () => {
        clearLog();
        // Allow scrolling during/after conversion
        document.body.style.overflow = "";
        document.body.style.height = "";
        document.body.style.paddingBottom = "30px"; // or whatever your footer's true height is
        // Reset working file list from the original input on each run
        files = Array.from(originalFiles);
        files.forEach(f => { f._original = f.webkitRelativePath; });

        if (multipleFontsCheckbox.checked) {
          // Group files by first subfolder (immediate children of top folder)
          const fontFolders = new Map();
          files.forEach(file => {
            const parts = file.webkitRelativePath.split('/');
            // Ignore files not in a subfolder
            if (parts.length > 1 && parts[1] && !file.name.startsWith('.')) {
              const fontFolder = parts[1];
              if (!fontFolders.has(fontFolder)) fontFolders.set(fontFolder, []);
              fontFolders.get(fontFolder).push(file);
            }
          });
          if (fontFolders.size === 0) {
            universalLog(logEl, "No subfolders found to process as fonts.", "error");
            return;
          }

          // --- Multiple Fonts, single ZIP containing all font folders ---
          const masterZip = new JSZip();

      for (const [fontFolderName, fontFiles] of fontFolders.entries()) {
        fileLogLines.length = 0; // reset plain-text log buffer for this font
        universalLog(logEl, "", "default"); // blank line before header
        logFontHeader(fontFolderName, sourceBoardEl.value, targetBoardEl.value, renameHighPassCheckbox.checked);
        const ffmpeg = new FFmpeg({ log: true, corePath: './ffmpeg/ffmpeg-core.js' });
        await ffmpeg.load();
        const mainHpSuffix = renameHighPassCheckbox.checked ? '_HP' : '';
        const rootBase =
          (targetBoardEl.value.toUpperCase() === 'GOLDEN_HARVEST'
            ? `sound1 - ${fontFolderName}_${targetBoardEl.value}`
            : `${fontFolderName}_${targetBoardEl.value}`);
        const rootFolderName = `${rootBase}${mainHpSuffix}`;
        const fontZip = masterZip;

        // Only process files for this font folder
        let fontFilesProcessed = [];
        for (const file of fontFiles) {
          fontFilesProcessed.push(file);
        }

        // Use shared audio processing helper (no logFn for rename)
        const processedFiles = await processAudioFiles({
          files: fontFilesProcessed,
          ffmpeg,
          highPass: renameHighPassCheckbox.checked
        });

        // Pre-process extras/tracks/non-wavs for this font
        let coreFiles = await handleExtrasAndTracks(processedFiles, fontZip, log, conversionLogEntries, rootFolderName);

        // Board-specific logic (same as before, but all use fontZip now)
        const src = sourceBoardEl.value.toUpperCase();
        const tgt = targetBoardEl.value.toUpperCase();

        if (src === "PROFFIE" && tgt === "PROFFIE") {
          await fat32ProffieOrganizer(coreFiles, mapping, rootFolderName, fontZip, log, conversionLogEntries);
        } else if (tgt === "CFX") {
          await CFXOrganizer(coreFiles, mapping, rootFolderName, fontZip, log, conversionLogEntries);
        } else if (tgt === "VERSO") {
          await VERSOOrganizer(coreFiles, mapping, rootFolderName, fontZip, log, conversionLogEntries);
        } else if (tgt === "GOLDEN_HARVEST") {
          await GHOrganizer(coreFiles, mapping, rootFolderName, fontZip, log, conversionLogEntries);
        } else if (tgt === "XENO3") {
          await XENO3Organizer(coreFiles, mapping, rootFolderName, fontZip, log, conversionLogEntries);
        } else if (tgt === "PROFFIE") {
          await fat32ProffieOrganizer(coreFiles, mapping, rootFolderName, fontZip, log, conversionLogEntries);
        }

        // Write this font‚Äôs conversion log to the ZIP from unified logger
        const header = buildLogHeader('Font Renaming Log', sourceBoardEl.value, targetBoardEl.value);
        const body   = fileLogLines.join('\n') + '\n';
        // Append Done line and footer banner to text log
        const doneLine = formatHeaderMsg(fontFolderName, sourceBoardEl.value, targetBoardEl.value).replace(/\.$/, ' Done.');
        const footerText = stripHtml(buildFooterBanner());
        masterZip.file(
          `${rootFolderName}/_Conversion_Log.txt`,
          header + '\n' + body + '\n' + doneLine + '\n' + footerText + '\n'
        );
        // On-screen footer for this font
        universalLog(logEl, "", "default");
        universalLog(
          logEl,
          formatHeaderMsg(fontFolderName, sourceBoardEl.value, targetBoardEl.value).replace(/\.$/, ' Done.'),
          "info"
        );
        universalLog(logEl, buildFooterBanner(), "default");
        universalLog(logEl, "", "default");
        universalLog(logEl, "", "default");
      }

          // Wait for all log messages to finish before showing zipping overlay
          function waitForLogDone() {
            return new Promise(resolve => {
              function check() {
                if (!logProcessing) resolve();
                else setTimeout(check, 15); // check every few ms
              }
              check();
            });
          }
          await waitForLogDone();
          showZippingOverlay(true);

          const mainHpSuffix = renameHighPassCheckbox.checked ? '_HP' : '';
          const blob = await masterZip.generateAsync({ type: 'blob' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `Renamed_MultipleFonts_${sourceBoardEl.value}_to_${targetBoardEl.value}${mainHpSuffix}.zip`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          // Hide zipping overlay
          showZippingOverlay(false);
          universalLog(logEl, "<br><br>");
          universalLog(logEl, "<br><br>");
          return; // Don't run the normal single-font flow
        }

        // === Single font/√ºber font logic (default) ===
        // Always create a new FFmpeg instance per run to reset memory
        const ffmpeg = new FFmpeg({ log: true, corePath: './ffmpeg/ffmpeg-core.js' });
        await ffmpeg.load();
        // Reset conversion log entries
        conversionLogEntries = [];
        clearLog();
        fileLogLines.length = 0;
        // Show header
        const baseName = originalFiles[0].webkitRelativePath.split('/')[0];
        universalLog(logEl, `Renaming font: "${baseName}" from ${sourceBoardEl.value} ‚Üí ${targetBoardEl.value}.`, "info");
        // Log high-pass status at the top if enabled
        if (renameHighPassCheckbox.checked) logHighPass(logEl, true);
        universalLog(logEl, "", "default");

        // Create new zip
        const zip = new JSZip();
        // Determine root folder name for zip, with optional HP suffix
        const mainHpSuffix = renameHighPassCheckbox.checked ? '_HP' : '';
        const rootBase =
          (targetBoardEl.value.toUpperCase() === 'GOLDEN_HARVEST'
            ? `sound1 - ${baseName}_${targetBoardEl.value}`
            : `${baseName}_${targetBoardEl.value}`);
        const rootFolderName = `${rootBase}${mainHpSuffix}`;

        // Use shared audio processing helper (no logFn for rename)
        files = await processAudioFiles({
          files,
          ffmpeg,
          highPass: renameHighPassCheckbox.checked
        });

        // Pre-process extras, tracks, and non-wavs
        let coreFiles = await handleExtrasAndTracks(files, zip, log, conversionLogEntries, rootFolderName);

        // Board-specific logic
        const src = sourceBoardEl.value.toUpperCase();
        const tgt = targetBoardEl.value.toUpperCase();

        if (src === "PROFFIE" && tgt === "PROFFIE") {
          await fat32ProffieOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          await finalizeAndDownloadWithOverlay(src, tgt, zip, rootFolderName);
        } else if (tgt === "CFX") {
          await CFXOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          await finalizeAndDownloadWithOverlay(src, tgt, zip, rootFolderName);
        } else if (tgt === "VERSO") {
          await VERSOOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          await finalizeAndDownloadWithOverlay(src, tgt, zip, rootFolderName);
        } else if (tgt === "GOLDEN_HARVEST") {
          await GHOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          await finalizeAndDownloadWithOverlay(src, tgt, zip, rootFolderName);
        } else if (tgt === "XENO3") {
          await XENO3Organizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          await finalizeAndDownloadWithOverlay(src, tgt, zip, rootFolderName);
        } else {
          // Fallback to Proffie organizer for any other case
          await fat32ProffieOrganizer(coreFiles, mapping, rootFolderName, zip, log, conversionLogEntries);
          await finalizeAndDownloadWithOverlay(src, tgt, zip, rootFolderName);
          return;
        }
      });



    // Audio‚ÄëOnly modal behavior
    const audioOnlyButton = document.getElementById('audioOnlyButton');
    const audioOnlyWindow = document.getElementById('audioOnlyWindow');
    const audioCloseButton = document.getElementById('audioCloseButton');

    audioOnlyButton.addEventListener('click', () => {
      // Hide main log when showing audio modal
      logEl.style.display = 'none';
      audioOnlyWindow.classList.add('visible');
    });
    audioCloseButton.addEventListener('click', () => {
      audioOnlyWindow.classList.remove('visible');
      // Restore main log when closing audio modal
      logEl.style.display = '';
    });

    // Define audio-only log helpers (after FFmpegWASM loaded)
    const audioLogEl = document.getElementById('audioLog');

    // Show "Ready to audio convert" on file selection
    const audioInput = document.getElementById('audioInput');
    audioInput.addEventListener('change', () => {
      // Clear previous messages and show ready info
      audioLogEl.innerHTML = '';
      const folderName = audioInput.files[0]?.webkitRelativePath.split('/')[0] || 'selected';
      universalLog(audioLogEl,`<span style="color:#99fff5; font-weight:bold">Ready to Convert Audio-Only - ${folderName}...</span>`);
      // Log high-pass readiness if checked
      const audioHighPassCheckbox = document.getElementById('audioHigh');
      if (audioHighPassCheckbox.checked) logHighPass(audioLogEl, true);
    });

    // Audio-only modal high-pass checkbox logging
    const audioHighPassCheckbox = document.getElementById('audioHigh');
    audioHighPassCheckbox.addEventListener('change', () => {
      removeHighPassNote();
        if (audioHighPassCheckbox.checked) logHighPass(audioLogEl, true);
    });

    // FFmpeg‚Äëwasm initialization and conversion logic
    document.getElementById('convertAudioButton').addEventListener('click', async () => {
      // Grab high-pass checkbox locally to avoid TDZ issues
      const audioHighPassCheckbox = document.getElementById('audioHigh');
      try {
        audioLogEl.innerHTML = "";
        audioFileLogLines.length = 0; // reset audio log buffer
        // Re-add header line showing folder name
        const folderName = document.getElementById('audioInput').files[0]?.webkitRelativePath.split('/')[0] || 'selected';
        universalLog(audioLogEl,`<span style="color:#99fff5; font-weight:bold">Converting Audio-Only - ${folderName}.</span>`);
        // Log high-pass status visibly and for zipped log if enabled
        if (audioHighPassCheckbox.checked) {
          universalLog(audioLogEl, "High-Pass filtering enabled.", "info", "high-pass-enabled");
        }

        // Add blank line before any moved/converted file logs
        universalLog(audioLogEl, "", "default");
        // Patch: Set corePath to ffmpeg/ffmpeg-core.js so FFmpegWASM finds the WASM binary
        const ffmpeg = new FFmpeg({
          log: true,
          corePath: './ffmpeg/ffmpeg-core.js'
        });
        await ffmpeg.load();
        // Create the zip object immediately after ffmpeg.load()
        const zip = new JSZip();

        // Gather files, skipping hidden dotfiles (do not log dotfiles)
        const allFiles = Array.from(document.getElementById('audioInput').files)
          .filter(file => !file.name.startsWith('.'));
        // Support WAV and MP3 files
        const audioFiles = allFiles.filter(file => {
          const lower = file.name.toLowerCase();
          return lower.endsWith('.wav') || lower.endsWith('.mp3');
        });

        // Compute folder suffix and root folder for zip
        const audioHPSuffix = audioHighPassCheckbox.checked ? '_HP' : '';
        const baseFolder = document.getElementById('audioInput').files[0]?.webkitRelativePath.split('/')[0] || 'selected';
        const rootZipFolder = `${baseFolder}${audioHPSuffix}`;

        // Log and zip only true non-audio/video files (e.g., images, txt), using full relative path
        allFiles.forEach(file => {
          const lower = file.name.toLowerCase();
          if (
            !lower.endsWith('.wav') &&
            !lower.endsWith('.mp3') &&
            !lower.endsWith('.mp4')
          ) {
            let rel = file.webkitRelativePath;
            while (rel.startsWith(baseFolder + "/")) {
              rel = rel.slice(baseFolder.length + 1);
            }
            const zipPath = rel ? `${rootZipFolder}/${rel}` : `${rootZipFolder}/${file.name}`;
            universalLog(audioLogEl,
              '<span style="color:#99fff5">- Moved non-audio file:</span> ' +
              `<span style="color:#fff">${file.webkitRelativePath}</span> ` +
              '<span style="color:#ff0">‚Üí</span> ' +
              `<span style="color:#9f6">${zipPath}</span>`
            );
            zip.file(zipPath, file);
          }
        });
        if (!audioFiles.length) {
          universalLog(audioLogEl,'<span style="color:#99fff5">Audio-Only: No audio files selected</span>');
          return;
        }

        // Use shared audio processing helper for audio files, with logFn for onscreen log and debug logging
        const processedAudioFiles = await processAudioFiles({
          files: audioFiles,
          ffmpeg,
          highPass: audioHighPassCheckbox.checked,
          logFn: (msg) => {
            // Remove HTML tags for console and mirror only the plain log line
            const txt = stripHtml(msg)
              .replace(/ +/g, ' ')         // collapse spaces
              .replace(/\n+/g, '\n')       // collapse newlines
              .replace(/ +‚Üí +/g, ' ‚Üí ');   // ensure arrow spacing
            if (txt) console.log(txt);
            universalLog(audioLogEl, msg, "info");
          }
        });
        // Only add WAV files to the zip (remove original MP3s)
        for (const file of processedAudioFiles) {
          // Only add .wav files (not mp3s)
          if (!file.name.toLowerCase().endsWith('.wav')) {
            console.warn("Skipping non-WAV in processedAudioFiles:", file.name);
            continue;
          }
          let rel = file._original || file.webkitRelativePath || file.name;
          // Ensure .wav extension in zip
          rel = rel.replace(/\.[^\.]+$/, '.wav');
          // Strip all leading baseFolder(s) from rel
          while (rel.startsWith(baseFolder + "/")) {
            rel = rel.slice(baseFolder.length + 1);
          }
          if (!rel) rel = file.name.replace(/\.[^\.]+$/, '.wav');
          const zipPath = `${rootZipFolder}/${rel}`;
          zip.file(zipPath, file);
        }

        // Add to onscreen log:
        universalLog(audioLogEl, "", "default");
        universalLog(audioLogEl, "Audio-Only Conversion complete.", "info");
        universalLog(audioLogEl, buildFooterBanner(), "default");

        // Add to Audio-Only Conversion log using the unified buffer:
        const header = buildLogHeader(
          'Audio-Only Conversion Log',
          '',
          '',
          '',
          audioHighPassCheckbox.checked
        );
        // Write plain-text Audio-Only Conversion log
        const body = audioFileLogLines.join('\n') + '\n';
        zip.file(`${rootZipFolder}/_Audio_Conversion_Log.txt`, header + '\n' + body);

        // Zip Converted files up
        const blob = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `Converted_Audio_${folderName}${audioHPSuffix}.zip`;
        document.body.appendChild(link);
        link.click();
        link.remove();
      } catch (e) {
        universalLog(audioLogEl,'Audio conversion failed: ' + e.message);
      }
    });

    const popup = document.getElementById('popup');
    const popupCloseButton = document.getElementById('popupCloseButton');
    const dontShowAgainCheckbox = document.getElementById('dontShowAgain');
    const versionChangelogButton = document.getElementById('versionChangelogButton');

    document.addEventListener('DOMContentLoaded', function () {
        // If you have other UI init, leave those too!
        // Example: closeButton.click(); fileInputButton.classList.remove('available');
        // Only keep if relevant. Otherwise, can remove/comment those two lines.

        // Check localStorage to determine if the popup should be shown
        const dontShowAgainFlag = localStorage.getItem('dontShowChangelog');
        if (dontShowAgainFlag === 'true') {
            dontShowAgainCheckbox.checked = true;
        } else {
            popup.classList.add('show');
        }

        popupCloseButton.addEventListener('click', function () {
            popup.classList.remove('show');
            localStorage.setItem('dontShowChangelog', dontShowAgainCheckbox.checked ? 'true' : 'false');
        });

        dontShowAgainCheckbox.addEventListener('change', function () {
            localStorage.setItem('dontShowChangelog', this.checked ? 'true' : 'false');
        });

        versionChangelogButton.addEventListener('click', function () {
            dontShowAgainCheckbox.checked = localStorage.getItem('dontShowChangelog') === 'true';
            popup.classList.add('show');
        });
    });

  </script>
</body>
  <div id="zippingOverlay">
    Zipping...<br>
    <span class="zipping-wait-text">Please wait</span>
  </div>
</html>

<!--
100% working!?
-->
